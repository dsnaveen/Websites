<!DOCTYPE html>

<!-- Mirrored from www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11B.php by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 11 Dec 2017 15:00:55 GMT -->
<head>
  <title>C++ Tutorial: Multi-Threaded Programming - C++11 B- 2017</title>
  <meta content="C++ Tutorial: Multi-Threaded Programming C++11 B" name="description" />
  <meta content="C++ Tutorial, Multi-Threaded Programming , MultiThreading Programming, join(), start(), wait, 
  C++11, sharing data between threads, lock_guard, mutex, race condition" name="keywords" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
  <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
  <link rel="stylesheet" href="../public/css/app.css">
  <link rel="stylesheet" href="../public/css/styles.css">
  <link rel="stylesheet" href="../public/css/bogostyleWidePreNew.css">
</head>

<body class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
    <div class="container-fluid">      
      <div class="navbar-header">
        <!--<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> -->
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar"> 
          <span class="sr-only">Toggle navigation</span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
        </button>
        <a class="navbar-brand" href="../index-2.html">BogoToBogo</a>
      </div>
      
      <div class="navbar-collapse collapse">
        
        <ul class="nav navbar-nav">
          <li class="active"><a href="../index-2.html">Home</a></li>
          <li><a href="../about_us.html">About</a></li>
          <li><a href="../Hadoop/BigData_hadoop_Install_on_ubuntu_single_node_cluster.html">Big Data</a></li>
          <li><a href="../python/scikit-learn/Artificial-Neural-Network-ANN-1-Introduction.html">Machine Learning</a></li>
          <li><a href="../AngularJS/AngularJS_Introduction.html">AngularJS</a></li> 
          <li><a href="../python/pytut.html">Python</a></li>
          <li><a href="cpptut.html">C++</a></li>
          <li><a href="../DevOps/DevOps_Jenkins_Chef_Puppet_Graphite_Logstash.html">DevOps </a></li>
          <li><a href="../Algorithms/algorithms.html">Algorithms</a></li> 
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">More...<b class="caret"></b></a>
            <ul class="dropdown-menu">
           
              <li><a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5</a></li>                           
              <li><a href="../Android/android.html">Android</a></li>
              
              <li><a href="../Linux/linux_tips1.html">Linux</a></li>
              <li><a href="../Java/tutorials/on_java.html">Java</a></li>
              <li><a href="../CSharp/.netframework.html">CSharp</a></li>
              <li><a href="../VideoStreaming/videostreaming_etc.html">Video Streaming</a></li>
              <li><a href="../FFMpeg/ffmpeg_fade_in_fade_out_transitions_effects_filters_slideshow_concat.html">FFmpeg</a></li>
              <li><a href="../Matlab/Matlab_Tutorial_Manipulating_Audio_I_Reverse_Delay_Tone_Control_Changing_Speed_Removing_Vocals.html">Matlab</a></li>
              <li><a href="../python/Django/Python_Django_Forums_Shared_Host.html">Django 1.8</a></li>
              <li><a href="../Laravel5/Laravel5_ToDo_List_Sample.html">Laravel 5.2</a></li>
              <li><a href="../RubyOnRails/RubyOnRails.html">Ruby On Rails</a></li>
              <li><a href="../HTML5/HTML5_Tutorial.html">HTML5 & CSS</a></li>
              <li><a href="../AmazingPlaces/index.html" target="_blank">
<img src="../Menus/MenuIcons/Earth_8px_transparent_background.png"
width="24" height="24"/>Earth</a> </li>
            </ul>
          </li>
        </ul>      
      </div>
    </div>  
  </nav>  

  <div id="main">
    <div class="container">
      <div class="row section featured topspace">
        <div class="row">
          <div class="col-sm-9 col-md-9 col-xs-9">
            <h2 class="section-title">
MultiThreading Programming with C++11 - Part B 
(Sharing Data - mutex, and race conditions, and deadlock)      <g:plusone></g:plusone></h2>
            <div class="icon-image">
                 <img src="images/cplusplus_icon.png" alt="cplusplus_icon.png"/>
            </div>
            <div class="SocialLinks">
  <span class='st__large' displayText=''></span>
  <br><br>
  <div align="center">
  <span class='st_facebook_large' displayText='Facebook'></span>
  <span class='st_twitter_large' displayText='Tweet'></span>
  <span class='st_linkedin_large' displayText='LinkedIn'></span>
  </div>
  <br><br>
  <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
  <script type="text/javascript">stLight.options({publisher: "b9569c43-5f56-4501-92f0-4bf4aa8fceb0", doNotHash: false, doNotCopy: true, hashAddressBar: false});</script>
</div>

<div id="bookmarkshare">
  <script type="text/javascript">var addthis_config = {"data_track_clickback":true};</script>
  <a class="addthis_button" href="http://www.addthis.com/bookmark.php?v=250&amp;username=khhong7"><img src="http://s7.addthis.com/static/btn/v2/lg-share-en.gif" width="125" height="16" alt="Bookmark and Share" style="border:0"/></a>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#username=khhong7"></script>
</div>

<br>
<hr>
<br>


<!-- Google bogo1 ad -->
<!-- Google search box -->



<!-- bogo1 -->
<div>
  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo1 -->
  <ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4716428189734495"
     data-ad-slot="6542308167"></ins>
  <script>
   (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


<!-- Google search box -->
<div class="AdSenseSearch">
  bogotobogo.com site search:
  <form action="http://www.google.com/" id="cse-search-box" target="_blank">
    <div>
      <input type="hidden" name="cx" value="partner-pub-4716428189734495:1794050961" />
      <input type="hidden" name="ie" value="UTF-8" />
      <!--<input type="text" name="q" size="55" />-->
      <input type="text" name="q" size="" width="90%"/>
      <input type="submit" name="sa" value="Search" />
    </div>
  </form>
  <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
</div>




<hr>
            <br><br><br>
<div class="subtitle" id="issue_sharing_data">Issues with sharing data</div>
<p>The issue of sharing data between threads are mostly due
to the consequences of modifying data. </p>

<!-- Google bogo_square_ad -->
<div>
  <script type="text/javascript">
    google_ad_client = "ca-pub-4716428189734495";
    /* bogo_LargeRectangle_336_280 */
    google_ad_slot = "2712696561";
    google_ad_width = 336;
    google_ad_height = 280;
  </script>
  <script type="text/javascript"
    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
  </script>
</div>
<br>





<p>If the data we share is read-only data, there will be no problem,
because the data read by one thread is unaffected by whether or not another thread is reading the
same data. However, once data is shared between threads, and one or more threads start
modifying the data, that's the start of problems. In this case, we must take
care to make sure that everything works out fine.</p>
<p>Some of the key words used in chapter are explained in 
<a href="multithreaded.html" target="_blank">Multi-Threaded Programming - Terminology</a>, 
such as 
<a href="multithreaded.html#RaceCondition" target="_blank">race Condition</a>, 
<a href="multithreaded.html#invariants" target="_blank">invariants</a>,  
<a href="multithreaded.html#Mutex" target="_blank">mutex</a>, and
<a href="multithreaded.html#Deadlock" target="_blank">deadlock</a> , 
etc.</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="mutexes">Mutexes</div>
<p>Here is an example of three threads are attempting the same list, <strong>myList</strong>:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;

using namespace std;

// <font color="blue">a global variable</font>
std::list&lt;int&amp;gtmyList;

void addToList(int max, int interval)
{
	for (int i = 0; i &lt; max; i++) {
		if( (i % interval) == 0) myList.push_back(i);
	}
}

void printList()
{
	for (auto itr = myList.begin(), end_itr = myList.end(); itr != end_itr; ++itr ) {
		cout &lt;&lt; *itr &lt;&lt; ",";
	}
}

int main()
{
	int max = 100;

	std::thread t1(addToList, max, 1);
	std::thread t2(addToList, max, 10);
	std::thread t3(printList);

	t1.join();
	t2.join();
	t3.join();

	return 0;
}
</pre>
<p>One of the possible output looks like this:</p>
<pre>
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
30,31,32,33,34,<font color="red">0,10,20,30,40,50,60,70,80,90,</font>42,43,44,45,46,47,48,49,50,51,52,53,
54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80
,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,
</pre>
<p>In the process of adding elements to the list, the thread <strong>t1</strong> that puts every integer from 0 to 100 competes with another thread <strong>t2</strong> that puts every 10th elements. Also, there is another competing thread, <strong>t3</strong> that accessed the same list to print out the list. As we see the results, the list failed to adding elements in order. This is due to the three threads accessed the list at the same time. So, to get the right list, we need some protection mechanism such as <strong>mutex</strong>.</p>
<p>Though mutexes are probably the most widely used data-protection mechanism in C++,
 it's important to structure our code to protect the right
data and avoid race conditions inherent in our interfaces. 
Mutexes also come with their own problems, in the form of a deadlock and 
protecting either too much or too little data.</p>
<p>In C++, we create a mutex by constructing an instance of <strong>std::mutex</strong>, lock it with a
call to the member function <strong>lock()</strong>, and unlock it with a call to the member function
<strong>unlock()</strong>. However, it is not a good practice to call the member functions
directly, because this means that we have to remember to call <strong>unlock()</strong> on every
code path out of a function, including those due to exceptions. </p>
<p>Instead, the Standard
C++ Library provides the <strong>std::lock_guard</strong> class template, which implements that
<strong>RAII</strong> idiom for a mutex. It <strong>locks the supplied mutex on construction</strong> and <strong>unlocks it
on destruction</strong>, thus ensuring a locked mutex is always correctly unlocked. </p>
<p>The example below shows how to protect a list that can be accessed by multiple threads
using a <strong>std::mutex</strong>, along with <strong>std::lock_guard</strong>. Both of these are declared in the <strong>
&lt;mutex&gt;</strong> header.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;mutex&gt;

using namespace std;

// <font color="blue">a global variable</font>
std::list&lt;int&gt;myList;

// <font color="blue">a global instance of std::mutex to protect global variable</font>
<font color="red">std::mutex myMutex;</font>

void addToList(int max, int interval)
{
	// <font color="blue">the access to this function is mutually exclusive</font>
	<font color="red">std::lock_guard&lt;std::mutex&gt; guard(myMutex);</font>
	for (int i = 0; i &lt; max; i++) {
		if( (i % interval) == 0) myList.push_back(i);
	}
}

void printList()
{
	// <font color="blue">the access to this function is mutually exclusive</font>
	<font color="red">std::lock_guard&lt;std::mutex&gt; guard(myMutex);</font>
	for (auto itr = myList.begin(), end_itr = myList.end(); itr != end_itr; ++itr ) {
		cout &lt;&lt; *itr &lt;&lt; ",";
	}
}

int main()
{
	int max = 100;

	std::thread t1(addToList, max, 1);
	std::thread t2(addToList, max, 10);
	std::thread t3(printList);

	t1.join();
	t2.join();
	t3.join();

	return 0;
}
</pre>
<p>The new output shows that we got the right process working on the list.</p>
<pre>
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,
30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56
,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,8
3,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,<font color="red">0,10,20,30,40,50,60,70,80,90,</font>
</pre>
<br/><br/>
<div class="subtitle_2nd" id="protecting_data_with_mutexes">Protecting data with mutexes</div>
<p>Protecting data with a <strong>mutex</strong> is not quite as easy as just putting a
<strong>std::lock_guard</strong> object in every member function. In other words,
 one stray pointer or reference makes 
all that protection for nothing. At one level, checking for stray pointers or references is
easy, as long as none of the member functions return a pointer or a reference to the protected
data to the caller either via a return value or via an out parameter, the data is
safe. </p>
However, it's not that straightforward. As well as
checking that the member functions that don't pass out pointers or references to their callers,
it's also important to check that they don't pass such pointers or references in to functions
they call that aren't under our control. This is just as dangerous because those functions
might store the pointer or reference in a place where it can later be used without the protection
of the <strong>mutex</strong>. Particularly dangerous in this regard are functions that are supplied
at runtime via a function argument or other means. The next code example demonstrates the code 
accidentally passing out a reference to protected data, which is a common mistake when trying to use 
mutexes to protect shared data:
<pre>
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

using namespace std;

class MyData
{
	int i;
	string s;
public:
	void doTask(int ii, string ss) 
	{
		i = ii;
		s = ss;
		cout &lt;&lt; " i = " &lt;&lt; i &lt;&lt; " s = " &lt;&lt; s &lt;&lt; endl;
	};
};

class DataWrapper
{
private:
	MyData data;
	std::mutex m;
public:
	template&lt;typename Function&gt;
	void processData(Function userFunc)
	{
		std::lock_guard&lt;std::mutex&gt; lock(m);

		// <font color="blue">passing</font> <font color="red">protected data</font> <font color="blue">to user-supplied function</font>
		userFunc(data);
	}
};

void goodFunction(MyData&amp; protectedData)
{
	protectedData.doTask(1, "my string");
}

MyData* unprotected;

void badFunction(MyData&amp; protectedData)
{
	unprotected = &amp;protectedData;
}

DataWrapper w;

void foo()
{
	w.processData(goodFunction);

	// <font color="blue">passing in a bad function</font>
	w.processData(badFunction);

	// <font color="blue">unprotected access to protected data</font>
	<font color="red">unprotected</font>-&gt;doTask(99, "hacked string");
}

int main()
{
	std::thread t(foo);

	t.join();

	return 0;
}
</pre>
<p>The output should look something like this:</p>
<pre>
 i = 1 s = my string
 i = 99 s = hacked string
</pre>
<p>Tthe code in <strong>processData()</strong> looks harmless enough, protected
with <strong>std::lock_guard</strong>, but the call to the user-supplied function <strong>userFunc</strong> means that
<strong>foo()</strong> can pass in <strong>badFunction()</strong> to bypass the protection and then call
<strong>do_task()</strong> without the mutex being locked.</p>
<p>The colde violates the rule:<br/>
"Don't pass pointers and references to protected data outside the scope of the lock, whether by
returning them from a function, storing them in externally visible memory, or passing them as
arguments to user-supplied functions."</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="where_race_condition">Race Conditions</div>
<p>Just because we're using a <strong>mutex</strong> or other mechanisms to protect shared data, we're
not necessarily protected from race conditions. We still have to ensure that the data should be protected properly. </p>
<p>Suppose we need a code to handle a <strong>doubly linked list</strong>.<br/>
In order for a thread to safely delete a node for a doubly linked list,
 we need to ensure that we're preventing concurrent accesses to three nodes: 
the node being deleted and the nodes on either side. If we
protect accesses to the pointers of each node individually, we'd be no better off
than with code that used no mutexes, because the race condition could still happen.
It's not the individual nodes that need protecting for the individual steps but the
whole data structure, for the whole delete operation. The easiest solution in this case
is to have a single mutex that protects the entire list.</p>
<p>Just because individual operations on the list are safe, we're not out of the woods
yet. We can still get race conditions, even with a really simple interface. Consider a
stack data structure like the <strong>std::stack</strong> container adapter shown in the example below. 
Aside from the constructors and <strong>swap()</strong>, 
there are only five things we can do to a <strong>std::stack</strong>:<br/>
<ol>
<li><strong>push()</strong> a new element onto the stack</li>
<li><strong>pop()</strong> an element off the stack</li>
<li>read the <strong>top()</strong> element</li>
<li>check whether it's <strong>empty()</strong></li>
<li> and read the number of elements-the <strong>size()</strong> of the stack.</li>
</ol>
<p>If we change <strong>top()</strong> so that it returns a copy rather than a reference and protect the internal
data with a <strong>mutex</strong>, this interface is still inherently subject to race conditions. This
problem is not unique to a mutex-based implementation; it's an <strong>interface problem</strong>, so
the <strong>race conditions</strong> would still occur with a <strong>lock-free implementation</strong>.</p>
<pre>

#include &lt;mutex&gt;
#include &lt;deque&gt;

using namespace std;

template&lt;typename T, typename Container = std::deque&lt;T&gt; &gt;
class stack
{
public:
	explicit stack(const Container&amp;);
	explicit stack(Container&amp;&amp; = Container());
	template &lt;typename Alloc&gt; explicit stack(const Alloc&amp;);
	template &lt;typename Alloc&gt; stack(const Container&amp;, const Alloc&amp;);
	template &lt;typename Alloc&gt; stack(Container&amp;&amp;, const Alloc&amp;);
	template &lt;typename Alloc&gt; stack(stack&amp;&amp;, const Alloc&amp;);

        // not reliable
	bool empty() const;

        // not reliable
	size_t size() const;

	T&amp; top();
	T const&amp; top() const;
	void push(T const&amp;);
	void push(T&amp;&amp;);
	void pop();
	void swap(stack&amp;&amp;);
};
</pre>
<p>The problem here is that the results of <strong>empty()</strong> and <strong>size()</strong> can't be relied on.
Although they might be correct at the time of the call, once they've returned, other
threads are free to access the stack and might <strong>push()</strong> new elements onto or <strong>pop()</strong> the
existing ones off of the stack before the thread that called <strong>empty()</strong> or <strong>size()</strong> could
use that information.</p>
<p>In particular, if the stack instance is not shared, it's safe to check for <strong>empty()</strong> and
then call <strong>top()</strong> to access the top element if the stack is not empty, as the code below:</p>
<pre>
stack<int> s;
if(!s.empty())
{
      int const value=s.top();
      s.pop();
      do_task(value);
}
</int></pre>
<p>Note that calling <strong>top()</strong> on an empty
stack may show undefined behavior. With a shared stack object, this call sequence (empty()-&gt;top()-&gt;pop()) is no longer
safe, because there might be a call to <strong>pop()</strong> from another thread that removes the last
element in between the call to <strong>empty()</strong> and the call to <strong>top()</strong>. 
<p>So, this is a classic race condition, and the use of a mutex internally to protect the stack contents
doesn't prevent it. That because it's a <strong>consequence of the interface</strong> rather than a consequence of not protecting underlying data properly.</p>
<p>
What's the solution? <br/>
Well, this problem happens as a consequence of the design
of the interface, so the solution is to change the interface. <br/>
What changes need to be made? <br/>
In the simplest case, we could just
declare that <strong>top()</strong> will throw an exception if there aren't any elements in the stack
when it's called. Though this directly addresses this issue, it makes for more cumbersome
programming, because now we need to be able to catch an exception, even if
the call to <strong>empty()</strong> returned false. This essentially makes the call to <strong>empty()</strong> completely
redundant.</p>
<p>If we look closely at the previous snippet, there's also potential for another race
condition but this time between the call to <strong>top()</strong> and the call to <strong>pop()</strong>. Consider
two threads running the previous snippet of code and both referencing the same
stack object, <strong>s</strong>. This isn't an unusual situation; when using threads for performance,
it's quite common to have several threads running the same code on different data,
and a shared stack object is ideal for dividing work between them. Suppose that initially
the stack has two elements, so we don't have to worry about the race between
<strong>empty()</strong> and <strong>top()</strong> on either thread, and consider the potential execution patterns.</p>
<p>If the stack is protected by a <strong>mutex</strong> internally, only one thread can be running a
stack member function at any one time, so the calls get nicely interleaved, while the
calls to <strong>do_task()</strong> can run concurrently. One possible execution is 
shown in table below.</p>
<table border="1">
<tr>
<th>Thread 1</th>
<th>Thread 2</th>
</tr>
<tr>
<td>if(!s.empty())</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>if(!s.empty())</td>
</tr>
<tr>
<td>int const value=s.top();</td>
<td> </td>
</tr>
<tr>
<td> </td>
<td>int const value=s.top();</td>
</tr>
<tr>
<td>s.pop();</td>
<td></td>
</tr>
<tr>
<td>do_task(value); </td>
<td>s.pop();</td>
</tr>
<tr>
<td> </td>
<td>do_task(value);</td>
</tr>
</table>
<p>As we can see, if these are all the threads running, there's nothing in between the
two calls to <strong>top()</strong> to modify the stack, so both threads will see the same value. Not only
that, but there are no calls to <strong>top()</strong> between the calls to <strong>pop()</strong>. Consequently, one of the
two values on the stack is discarded without ever having been read, whereas the other
is processed twice. This is yet another race condition and far more insidious than the
undefined behavior of the <strong>empty()/top()</strong> race; there's never anything obviously
wrong going on, and the consequences of the bug are likely far removed from the
cause, although they obviously depend on exactly what <strong>do_task()</strong> really does.</p>
<p>
This calls for a more radical change to the interface, one that combines the calls to
<strong>top()</strong> and <strong>pop()</strong> under the protection of the <strong>mutex</strong>. A
combined call can lead to issues if the copy constructor for the objects on the stack
can throw an exception. This problem was dealt with fairly comprehensively from an
exception-safety point of view by Herb Sutter but the potential for race conditions
brings something new to the mix.</p>
<p>For those of us who aren't aware of the issue, consider a <strong>stack&lt;vector&lt;int&gt;&gt;</strong>.
Now, a vector is a dynamically sized container, so when we copy a vector the library
has to allocate some more memory from the heap in order to copy the contents. If the
system is heavily loaded, or there are significant resource constraints, this memory
allocation can fail, so the copy constructor for vector might throw a <strong>std::bad_alloc</strong>
exception. This is especially likely if the vector contains a lot of elements. If the <strong>pop()</strong>
function was defined to return the value popped, as well as remove it from the stack,
we have a potential problem: the value being popped is returned to the caller only
after the stack has been modified, but the process of copying the data to return to the
caller might throw an exception. If this happens, the data just popped is lost; it has
been removed from the stack, but the copy was unsuccessful!</p>
<p>The designers of the
<strong>std::stack</strong> interface helpfully split the operation in two:
<ol>
<li>get the top element (<strong>top()</strong>)</li>
<li>remove it from the stack (<strong>pop()</strong>)</li>
</ol>
<p>So, if we can't safely copy the data, it
stays on the stack. If the problem was lack of heap memory, maybe the application can
free some memory and try again.</p>
<p>
Unfortunately, it's precisely this <strong>split</strong> that we're trying to avoid in eliminating the
race condition! </p>
<p>However, we have 4 options though they aren't without cost.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="option1">Option 1 - Passing in a reference</div>
<p>The first option is to pass a reference to a variable in which we want to receive the
popped value as an argument in the call to <strong>pop()</strong>:</p>
<pre>
vector&lt;int&gt; v;
myStack.pop(v);
</pre>
<p>But this option has the distinct disadvantage that </p>
<ol>
<li>tt requires the
calling code to construct an instance of the stack's value type (in our case, it is &lt;int&gt;) prior to the call, in order
to pass this in as the target. For some types, this is impractical, because constructing an
instance is expensive in terms of time or resources. For other types this isn't always
possible, because the constructors require parameters (int our case, it is typename "Alloc") that aren't necessarily available
at this point in the code. </li>
<li>it requires that the stored type is assignable. This is an
important restriction: many user-defined types do not support assignment, 
though they may support move construction or even copy construction, and thus allow return
by value.</li>
</ol>
</p>
<br/>
<br/>
<div class="subtitle_2nd" id="option2">Option 2 - No-throw copy or move constructor</div>
<p>There's only an exception safety problem with a <strong>value-returning pop()</strong> if the return by
value can throw an exception. Many types have copy constructors that don't throw
exceptions, and with the new <strong>rvalue-reference</strong> support in the C++ Standard, 
many more types will have a move constructor that doesn't
throw exceptions, even if their copy constructor does. One valid option is to restrict
the use of our thread-safe stack to those types that can safely be returned by value
without throwing an exception.</p>
<p>Although this is safe, it's not ideal. Even though we can detect at compile time
the existence of a copy or move constructor that doesn't throw an exception using the
<strong>std::is_nothrow_copy_constructible</strong> and <strong>std::is_nothrow_move_constructible</strong>
type traits, it's quite limiting. There are many more user-defined types with copy constructors
that can throw and don't have move constructors than there are types with
copy and/or move constructors that can't throw although this might change as people
get used to the rvalue-reference support in C++11. It would be unfortunate if
such types couldn't be stored in our thread-safe stack.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="option3">Option 3 - Return a pointer to the popped item</div>
<p>The third option is to return a pointer to the popped item rather than return the item
by value. The advantage here is that pointers can be freely copied without throwing an
exception, so we've avoided Cargill's exception problem. <p>
<p>The disadvantage is that
returning a pointer requires a means of managing the memory allocated to the
object, and for simple types such as integers, the overhead of such memory management
can exceed the cost of just returning the type by value. For any interface that
uses this option, <strong>std::shared_ptr</strong> would be a good choice of pointer type; not only
does it avoid memory leaks, because the object is destroyed once the last pointer is
destroyed, but the library is in full control of the memory allocation scheme and
doesn't have to use new and delete. This can be important for optimization purposes:
requiring that each object in the stack be allocated separately with new would impose
quite an overhead compared to the original non-thread-safe version.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="option4">Option 4 - Combination of option 1-4</div>
<p>option1 and (option2 or option3) - If we've chosen
option 2 or 3, it's relatively easy to provide option 1 as well, and this provides users of
our code the ability to choose whichever option is most appropriate for them for very
little additional cost.</p>
<p>The code below shows the class definition for a stack with no race conditions in the interface
and that implements options 1 and 3: there are two overloads of <strong>pop()</strong>, one that takes a
reference to a location in which to store the value and one that returns a <strong>std::shared_
ptr&lt;&gt;</strong>. It has a simple interface, with only two functions: <strong>push()</strong> and <strong>pop()</strong>.
</p>
<pre>
#include &lt;exception&gt;
#include &lt;memory&gt; // std::shared_ptr&lt;&gt;
struct empty_stack: std::exception
{
	const char* what() const throw();
};

template&lt;typename T&gt;
class threadsafeStack
{
public:
	threadsafeStack();
	threadsafeStack(const threadsafeStack&amp;);
	threadsafeStack&amp; operator=(const threadsafeStack&amp;) = delete;
	void push(T new_value);
	std::shared_ptr&lt;T&gt; pop();
	void pop(T&amp; value);
	bool empty() const;
};
</pre>
<p>By paring down the interface we allow for maximum safety; even operations on the
whole stack are restricted. The stack itself can't be assigned, because the assignment
operator is deleted, and there's no <strong>swap()</strong> function.</p>
<p>
It can, however, be copied, assuming the stack elements can be copied. The <strong>pop()</strong>
functions throw an empty_stack exception if the stack is empty, so everything still
works even if the stack is modified after a call to <strong>empty()</strong>. As mentioned in the
description of option 3, the use of <strong>std::shared_ptr</strong> allows the stack to take care of
the memory-allocation issues and avoid excessive calls to new and delete if desired.</p>
<p>
Our five stack operations have now become three: <strong>push()</strong>, <strong>pop()</strong>, 
and <strong>empty()</strong>. Even
<strong>empty()</strong> is superfluous. This simplification of the interface allows for better control
over the data; we can ensure that the mutex is locked for the entirety of an operation.
The following listing shows a simple implementation that's a wrapper around
<strong>std::stack&lt;&gt;</strong>.</p>
<pre>
#include &lt;exception&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;stack&gt;

struct empty_stack: std::exception
{
	const char* what() const throw();
};

template&lt;typename T&gt;
class threadsafeStack
{
private:
	std::stack&lt;T&gt; data;
	mutable std::mutex m;
public:
	threadsafeStack(){}

	threadsafeStack(const threadsafeStack&amp; other)
	{
		std::lock_guard&lt;std::mutex&gt; lock(other.m);

                // <font color="blue">copy in constructor body rather than </font>
                // <font color="blue">the member initializer list </font>
                // <font color="blue">in order to ensure that the mutex is held across the copy.</font>
		data=other.data;
	}

	threadsafeStack&amp; operator=(const threadsafeStack&amp;) = delete;
	void push(T new_value)
	{
		std::lock_guard&lt;std::mutex&gt; lock(m);
		data.push(new_value);
	}

	std::shared_ptr&lt;T&gt; pop()
	{
		std::lock_guard&lt;std::mutex&gt; lock(m);

                // <font color="blue">check for empty before trying to pop value</font>
		if(data.empty()) throw empty_stack();

                // <font color="blue">allocate return value before modifying stack</font>
		std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top()));
		data.pop();
		return res;
	}

	void pop(T&amp; value)
	{
		std::lock_guard&lt;std::mutex&gt; lock(m);
		if(data.empty()) throw empty_stack();
		value=data.top();
		data.pop();
	}

	bool empty() const
	{
		std::lock_guard&lt;std::mutex&gt; lock(m);
		return data.empty();
	}
};
</pre>
<p>This stack implementation is actually copyable-the copy constructor locks the mutex
in the source object and then copies the internal stack. We do the copy in the constructor
body rather than the member initializer list in order to ensure that the
<strong>mutex</strong> is held across the copy.</p>
<p>As the discussion of <strong>top()</strong> and <strong>pop()</strong> shows, 
problematic race conditions in interfaces
essentially arise because of locking at too small a granularity; the protection
doesn't cover the entirety of the desired operation. </p>
<p>Problems with <strong>mutexes</strong> can also
arise from locking at too large a granularity; the extreme situation is a single <strong>global
mutex</strong> that protects all shared data. In a system where there's a significant amount of
shared data, this can eliminate any performance benefits of concurrency, because the
threads are forced to run one at a time, even when they're accessing different bits of
data. The first versions of the Linux kernel that were designed to handle multiprocessor
systems used a single global kernel lock. Although this worked, 
it meant that a two-processor system typically had much worse performance than two single-processor
systems, and performance on a four-processor system was nowhere near
that of four single-processor systems. There was too much contention for the kernel, so
the threads running on the additional processors were unable to perform useful work.
Later revisions of the Linux kernel have moved to a more fine-grained locking
scheme, so the performance of a four-processor system is much nearer the ideal of
four times that of a single-processor system, because there's far less contention.</p>
<p>
<p>One issue with <strong>fine-grained locking schemes</strong> is that sometimes we need more
than one mutex locked in order to protect all the data in an operation. As described
previously, sometimes the right thing to do is increase the granularity of the data covered
by the mutexes, so that only one mutex needs to be locked. However, sometimes
that's undesirable, such as when the mutexes are protecting separate instances of a
class. In this case, locking at the next level up would mean either leaving the locking
to the user or having a single mutex that protected all instances of that class, neither
of which is particularly desirable.</p>
<p>
If we end up having to lock two or more mutexes for a given operation, there's
another potential problem lurking in the wings: <strong>deadlock</strong>. This is almost the opposite
of a race condition: rather than two threads racing to be first, each one is waiting for
the other, so neither makes any progress.</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="deadlock">Deadlock</div>
<p><a href="multithreaded.html#Deadlock" target="_blank">Deadlock</a> is the biggest problem with
having to lock two or more <strong>mutexes</strong> in order to perform an operation.</p>
<p>One of the most common ways of avoiding deadlock is to always <strong>lock the two mutexes in the
same order</strong>: if we always lock <strong>mutex A</strong> before <strong>mutex B</strong>, then we'll never deadlock.
Sometimes this is straightforward, because the mutexes are serving different purposes,
but other times it's not so simple, such as when the mutexes are each protecting
a separate instance of the same class.</p>
<p>As an example, let's think about an operation that exchanges data between two instances of the same class.
In order to ensure that the
data is exchanged correctly, without being affected by concurrent modifications,
the mutexes on both instances must be locked. However, if a fixed order is chosen such as, 
 the mutex for the instance supplied as the first parameter, then the
mutex for the instance supplied as the second parameter. This can backfire, however, all it
takes is for two threads to try to exchange data between the same two instances with
the parameters swapped, and we have <strong>deadlock</strong>!</p>
<p>However, the C++ Standard Library has a cure for this in the form of <strong>std::lock</strong> which is 
a function that can <strong>lock two or more mutexes at once without risk of deadlock</strong>.</p>
<p>The example below  shows how to use <strong>std::lock</strong> for a simple swap operation.</p>
<pre>
#include &lt;mutex&gt;

using namespace std;

class MyObjectClass {};

void swap(MyObjectClass&amp; lhs,MyObjectClass&amp; rhs);

class X
{
private:
	MyObjectClass myObj;
	std::mutex m;
public:
	X(MyObjectClass const&amp; obj):myObj(obj){}
	friend void swap(X&amp; lhs, X&amp; rhs)
	{
		// <font color="blue">the arguments are checked to ensure they are different instances, </font>
		// <font color="blue">because attempting to acquire a lock on a std::mutex </font>
		// <font color="blue">when we already hold it is undefined behavior. </font>
		if(&amp;lhs;==&amp;rhs;) return;

		// <font color="blue">the call to std::lock() locks the two mutexes</font>
		std::lock(lhs.m,rhs.m);

		// <font color="blue">two std::lock_guard instances are constructed one for each mutex.</font>
		std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m,std::adopt_lock);
		std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m,std::adopt_lock);

		swap(lhs.myObj, rhs.myObj);
	}
};
</pre>
<p>The code checks the arguments to ensure they are different instances, because
attempting to acquire a lock on a <strong>std::mutex</strong> when we already hold it is undefined
behavior. A mutex that does permit multiple locks by the same thread is provided in
the form of <strong>std::recursive_mutex</strong>. Then, the call to
<strong>std::lock()</strong> locks the two mutexes, and two <strong>std::lock_guard</strong> instances are constructed
 one for each mutex. The <strong>std::adopt_lock</strong> parameter is supplied in
addition to the mutex to indicate to the <strong>std::lock_guard</strong> objects that the mutexes
are already locked, and they should just adopt the ownership of the existing lock on
the mutex rather than attempt to lock the mutex in the constructor.</p>
<p>This ensures that the mutexes are correctly unlocked on function exit in the general
case where the protected operation might throw an exception; it also allows for a
simple return. Also, it's worth noting that locking either <strong>lhs.m</strong> or <strong>rhs.m</strong> inside the call
to <strong>std::lock</strong> can throw an exception. in that case, the exception is propagated out
of <strong>std::lock</strong>. If <strong>std::lock</strong> has successfully acquired a lock on one mutex and an exception is thrown when it tries to acquire a lock on the other mutex, this first lock is
released automatically: <strong>std::lock</strong> provides all-or-nothing semantics with regard to
locking the supplied mutexes.</p>
<p>Although <strong>std::lock</strong> can help us to avoid deadlock in those cases where we need to
acquire two or more locks together, it doesn't help if they're acquired separately. In
that case we have to rely on our discipline as developers to ensure we don't get
deadlock. This isn't easy: deadlocks are one of the nastiest problems to encounter in
multithreaded code and are often unpredictable, with everything working fine the
majority of the time. There are, however, some relatively simple rules that can help
us to write <strong>deadlock-free</strong> code.</p>
<br/>
<br/>
<div class="subtitle" id="how_to_avoid_deadlock">How to avoid deadlock</div>
<p>Though locks are the most frequent cause of deadlock, it does not just occur with locks.
We can create deadlock with two threads and no locks just by having each thread call
<strong>join()</strong> on the <strong>std::thread</strong> object for the other.
 In this case, neither thread can make
progress because it's waiting for the other to finish. </p>
<p>This simple cycle can occur anywhere that a thread can wait for another
thread to perform some action if the other thread can simultaneously be waiting for
the first thread, and it isn't limited to two threads: a cycle of three or more threads will
still cause deadlock. </p>
<p>The guidelines for avoiding deadlock all boil down to one idea:
<font color="red">don't wait for another thread if there's a chance it's waiting for you</font>. The individual
guidelines provide ways of identifying and eliminating the possibility that the other
thread is waiting for you.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="nested_lock">Avoid nested lock</div>
<p>The first idea is the simplest: <strong>don't acquire a lock if we already hold one</strong>. If we stick
to this guideline, it's impossible to get a deadlock from the lock usage alone because
each thread only ever holds a single lock. We could still get deadlock from other
things such as the threads waiting for each other. However, mutex locks are probably the
most common cause of deadlock. If we need to acquire multiple locks, do it as a single
action with <strong>std::lock</strong> in order to acquire them without deadlock.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="acquire_locks_in_a_fixed_order">Acquire locks in a fixed order</div>
<p>In case we must acquire two or more locks, and we can't acquire them as a single
operation with <strong>std::lock</strong>, we should acquire them in the same order in every thread. 
The key is to define <strong>the order in a way that's consistent 
between threads</strong>. </p>
<p>In some cases, this is relatively easy. For example, look at the
stack from <a href="#option4">Race Condition: Option4</a>-the mutex is internal to each stack instance,
 but the operations
on the data items stored in a stack require calling user-supplied code. We can,
however, add the constraint that none of the operations on the data items stored in
the stack should perform any operation on the stack itself. This puts the burden on the
user of the stack, but it's rather uncommon for the data stored in a container to access
that container, and it's quite apparent when this is happening, so it's not a particularly
difficult burden to carry.</p>
<p>In other cases, this isn't so straightforward, as was the swap operation
in <a href="#deadlock">deadlock</a>. At least in that case we could lock the mutexes simultaneously,
but that's not always possible. If we look back at the linked list example,
 we'll see that one possibility for protecting the list is to have a mutex per
node. Then, in order to access the list, threads must acquire a lock on every node
they're interested in. </p>
<p>For a thread to delete an item, it must then acquire the lock on
three nodes: the node being deleted and the nodes on either side, because they're all
being modified in some way. Likewise, to traverse the list a thread must keep hold of
the lock on the current node while it acquires the lock on the next one in the
sequence, in order to ensure that the next pointer isn't modified in the meantime.
Once the lock on the next node has been acquired, the lock on the first can be
released because it's no longer necessary.</p>
<p>This <strong>hand-over-hand locking</strong> style allows multiple threads to access the list, provided
each is accessing a different node. However, in order to prevent deadlock, the
<strong>nodes must always be locked in the same order</strong>: if two threads tried to traverse the list
in reverse order using hand-over-hand locking, they could deadlock with each other in
the middle of the list. If nodes A and B are adjacent in the list, the thread going one
way will try to hold the lock on node A and try to acquire the lock on node B. A thread
going the other way would be holding the lock on node B and trying to acquire the
lock on node A-a classic scenario for deadlock.</p>
<p>When deleting node B that lies between nodes A and C, if that thread
acquires the lock on B before the locks on A and C, it has the potential to deadlock
with a thread traversing the list. Depending on the direction of traversal, such a thread would try to lock either A or C first
 but would then find that it couldn't obtain a
lock on B because the thread doing the deleting was holding the lock on B and trying
to acquire the locks on A and C.</p>
<p>
One way to prevent deadlock here is to define an <strong>order of traversal</strong>, so a thread
must always lock A before B and B before C. This would eliminate the possibility of
deadlock at the expense of disallowing reverse traversal. Similar conventions can
often be established for other data structures.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="nested_lock">Avoid a call to user-supplied code while holding a lock</div>
<p>If the code is user supplied,
we have no idea what it could do; it could do anything, including acquiring a
lock. If we call user-supplied code while holding a lock, and that code acquires a lock,
we've violated the guideline on avoiding nested locks and could get deadlock. Sometimes
this is unavoidable; if we're writing generic code such as the stack in previous sample,
every operation on the parameter type or types is user-supplied code. In this case, we
need a new guideline.</p>
<br/>
<br/>
<div class="subtitle_2nd" id="Use_a_lock_hierarchy">Use a lock hierarchy</div>
<p>Although this is really a particular case of defining lock ordering, a <strong>lock hierarchy</strong> can
provide a means of checking that the convention is adhered to at runtime. The idea is
that we divide our application into layers and identify all the mutexes that may be
locked in any given layer. When code tries to lock a mutex, it isn't permitted to lock
that mutex if it already holds a lock from a lower layer. We can check this at runtime
by assigning layer numbers to each mutex and keeping a record of which mutexes are
locked by each thread. </p>
</p></p></p></p></p>
<div>
    
<div class="custom-disqus">
<!-- Disqus -->
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
/* Disabling Disqus 4/26/2017
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
 Disabling Disqus */    
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br></div>
          </div>
          <div class="col-sm-3 col-md-3 col-xs-3">
  	    <div class="g-person" data-width="1" data-href="//plus.google.com/111664369941456137911" data-rel="author">
  	    </div>
            <div class="resume">
              <p>Ph.D. / Golden Gate Ave, San Francisco / Seoul National Univ / Carnegie Mellon / UC Berkeley / DevOps / Deep Learning / Visualization</p>
            </div>
  	    <div>
                
<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>




<!-- Place this tag after the last widget tag. -->
<script type="text/javascript">
        (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/platform.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
</script>
  	    </div>
  	    <div class="side_menu">
                <br /><br />

<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>

<!-- cplusplus_list_INNER.php -->
<br><br><br>
<h1>C++ Tutorials</h1>
   <a href="cpptut.html">C++ Home</a> 
   <br><br>
   <a href="../Algorithms/algorithms.html">Algorithms & Data Structures in C++ ...</a>
   <br><br>
   <a href="application_visual_studio_2013.html">Application (UI) - using Windows Forms (Visual Studio 2013/2012)</a>
   <br><br>
   <a href="autoptr.html">auto_ptr</a>
   <br><br>
   <a href="binarytree.html">Binary Tree Example Code</a>
   <br><br>
   <a href="blackjackQT.html">Blackjack with Qt</a>
   <br><br>
   <a href="boost.html">Boost - shared_ptr, weak_ptr, mpl, lambda, etc.</a>
   <br><br>
   <a href="Boost/boost_AsynchIO_asio_tcpip_socket_server_client_timer_A.html">Boost.Asio (Socket Programming - Asynchronous TCP/IP)...</a>
   <br><br>
   <a href="class.html">Classes and Structs</a> 
   <br><br>
   <a href="constructor.html">Constructor</a> 
   <br><br>
   <a href="cplusplus11.html">C++11(C++0x): rvalue references, move constructor, and lambda, etc.</a> 
   <br><br>
   <a href="cpptesting.html">C++ API Testing</a>
   <br><br>
   <a href="cplusplus_keywords.html">C++ Keywords - const, volatile, etc.</a>
   <br><br>
   <a href="CppCrashDebuggingMemoryLeak.html">Debugging Crash & Memory Leak</a>
   <br><br>
   <a href="../DesignPatterns/introduction.html">Design Patterns in C++ ...</a>
   <br><br>
   <a href="dynamic_cast.html">Dynamic Cast Operator</a>
   <br><br>
   <a href="eclipse_CDT_JNI_MinGW_64bit.html">Eclipse CDT / JNI (Java Native Interface) / MinGW</a>
   <br><br>
   <a href="embeddedSystemsProgramming.html">Embedded Systems Programming I - Introduction</a>
   <br><br>
   <a href="embeddedSystemsProgramming_gnu_toolchain_ARM_cross_compiler.html">Embedded Systems Programming II - gcc ARM Toolchain and Simple Code on Ubuntu and Fedora</a>
   <br><br>
   <a href="embeddedSystemsProgramming_GNU_ARM_ToolChain_Eclipse_CDT_plugin.html">Embedded Systems Programming III - Eclipse CDT Plugin for gcc ARM Toolchain </a>
   <br><br>
   <a href="exceptions.html">Exceptions</a> 
   <br><br>
   <a href="friendclass.html">Friend Functions and Friend Classes</a>
   <br><br>
   <a href="fstream_input_output.html">fstream: input & output</a>
   <br><br>
   <a href="function_overloading.html">Function Overloading</a>
   <br><br>
   <a href="functor_function_object_stl_intro.html">Functors (Function Objects) I - Introduction</a>
   <br><br>
   <a href="functor_function_object_stl_2.html">Functors (Function Objects) II - Converting function to functor</a>
   <br><br>
   <a href="functors.html">Functors (Function Objects) - General</a>
   <br><br>
   <br><br>
   <a href="Git/Git_GitHub_Express.html">Git and GitHub Express...</a>
   <br><br>
   <a href="google_unit_test_gtest.html">GTest (Google Unit Test) with Visual Studio 2012</a>
   <br><br>
   <a href="multipleinheritance.html">Inheritance & Virtual Inheritance (multiple inheritance) </a>
   <br><br>
   <a href="libraries.html">Libraries - Static, Shared (Dynamic)</a>
   <br><br>
   <a href="linked_list_basics.html">Linked List Basics</a>
   <br><br>
   <a href="linkedlist.html">Linked List Examples</a>
   <br><br>
   <a href="make.html">make & CMake</a>
   <br><br>
   <a href="gnumake.html">make (gnu)</a>
   <br><br>
   <a href="memoryallocation.html">Memory Allocation</a>
   <br><br>
   <a href="multithreaded.html">Multi-Threaded Programming - Terminology - Semaphore, Mutex, Priority Inversion etc.</a>
   <br><br>
   <a href="multithreading_win32A.html">Multi-Threaded Programming II -  Native Thread for Win32 (A) </a>
   <br><br>
   <a href="multithreading_win32B.html">Multi-Threaded Programming II -  Native Thread for Win32 (B) </a>
   <br><br>
   <a href="multithreading_win32C.html">Multi-Threaded Programming II -  Native Thread for Win32 (C) </a>
   <br><br>
   <a href="multithreading_win32.html">Multi-Threaded Programming II - C++ Thread for Win32</a>
   <br><br>
   <a href="multithreading_pthread.html">Multi-Threaded Programming III - C/C++ Class Thread for Pthreads</a>
   <br><br>
   <a href="multithreading_ipc.html">MultiThreading/Parallel Programming - IPC</a>
   <br><br>
   <a href="multithreaded4_cplusplus11.html">Multi-Threaded Programming with C++11 Part A (start, join(), detach(), and ownership)</a>
   <br><br>
   <a href="multithreaded4_cplusplus11B.html">Multi-Threaded Programming with C++11 Part B (Sharing Data - mutex, and race conditions, and deadlock)</a>
   <br><br>
   <a href="multithreadedDebugging.html">Multithread Debugging</a>
   <br><br>
   <a href="object_returning.html">Object Returning</a>
   <br><br>
   <a href="slicing.html">Object Slicing and Virtual Table</a>
   <br><br>
   <a href="opencv.html">OpenCV with C++</a> 
   <br><br>
   <a href="operatoroverloading.html">Operator Overloading I</a> 
   <br><br>
   <a href="operator_oveloading_self_assignment.html">Operator Overloading II - self assignment</a> 
   <br><br>
   <a href="valuevsreference.html">Pass by Value vs. Pass by Reference</a>
   <br><br>
   <a href="pointers.html">Pointers</a>
   <br><br>
   <a href="pointers2_voidpointers_arrays.html">Pointers II - void pointers & arrays</a>
   <br><br>
   <a href="pointers3_function_multidimensional_arrays.html">Pointers III - pointer to function & multi-dimensional arrays</a>
   <br><br>
   <a href="preprocessor_macro.html">Preprocessor - Macro</a>
   <br><br>
   <a href="private_inheritance.html">Private Inheritance</a>
   <br><br>
   <a href="../python/python_cpp_sip.html">Python & C++ with SIP</a>
   <br><br>
   <a href="RandomNumbers.html">(Pseudo)-random numbers in C++</a>
   <br><br>
   <a href="references.html">References for Built-in Types</a>
   <br><br>
   <a href="sockets_server_client.html">Socket - Server & Client</a>
   <br><br>
    <a href="sockets_server_client_QT.html">Socket - Server & Client with Qt (Asynchronous / Multithreading / ThreadPool etc.)</a>
   <br><br>
   <a href="stackunwinding.html">Stack Unwinding</a>
   <br><br>
   <a href="stl_vector_list.html">Standard Template Library (STL) I - Vector & List</a>
   <br><br>
   <a href="stl2_map.html">Standard Template Library (STL) II - Maps</a>
   <br><br>
   <a href="stl2_unorderd_map_cpp11_hash_table_hash_function.html">Standard Template Library (STL) II - unordered_map</a>
   <br><br>
   <a href="stl2B_set.html">Standard Template Library (STL) II - Sets</a>
   <br><br>
   <a href="stl3_iterators.html">Standard Template Library (STL) III - Iterators</a>
   <br><br>
   <a href="stl4_algorithms.html">Standard Template Library (STL) IV - Algorithms</a>
   <br><br>
   <a href="stl5_function_objects.html">Standard Template Library (STL) V - Function Objects</a>
   <br><br>
   <a href="statics.html">Static Variables and Static Class Members</a>
   <br><br>
   <a href="string.html">String</a> 
   <br><br>
   <a href="string2.html">String II - sstream etc.</a> 
   <br><br>
   <a href="assembly.html">Taste of Assembly</a>
   <br><br>
   <a href="templates.html">Templates</a>
   <br><br>
   <a href="template_specialization_function_class.html">Template Specialization</a>
   <br><br>
   <a href="template_specialization_traits.html">Template Specialization - Traits</a>
   <br><br>
   <a href="template_declaration_definition_header_implementation_file.html">Template Implementation & Compiler (.h or .cpp?)</a>
   <br><br>
   <a href="this_pointer.html">The this Pointer</a>
   <br><br>
   <a href="typecast.html">Type Cast Operators</a>
   <br><br>
   <a href="upcasting_downcasting.html">Upcasting and Downcasting</a>
   <br><br>
   <a href="virtual_destructors_shared_ptr.html">Virtual Destructor & boost::shared_ptr</a>
   <br><br>
   <a href="virtualfunctions.html">Virtual Functions</a>
   <br><br>
   <br><br>
   <i>Programming Questions and Solutions &darr;</i>
      <br><br>
       <a href="quiz_strings_arrays.html">Strings and Arrays</a>
       <br><br>
       <a href="quiz_linkedlist.html">Linked List</a>
       <br><br>
       <a href="quiz_recursion.html">Recursion</a>
       <br><br>
       <a href="quiz_bit_manipulation.html">Bit Manipulation</a> 
       <br><br>
       <a href="smallprograms.html">Small Programs (string, memory functions etc.)</a>
       <br><br>
       <a href="quiz_math_probability.html">Math & Probability</a>
       <br><br>
       <a href="quiz_multithreading.html">Multithreading</a>
       <br><br>
       <a href="google_interview_questions.html">140 Questions by Google</a> 
       <br><br>
       <br><br>
   <a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5 EXPRESS...</a>
   <br><br>
   <a href="../Win32API/Win32API_DLL.html">Win32 DLL ...</a>
   <br><br>
   <a href="cppNews.html">Articles On C++</a> 
   <br><br>
   <a href="C11/C11_initializer_list.html">What's new in C++11...</a> 
   <br><br>
   <a href="C11/1_C11_creating_thread.html">C++11 Threads EXPRESS...</a> 
   <br><br>
   <a href="../OpenCV/opencv_3_tutorial_imgproc_gausian_median_blur_bilateral_filter_image_smoothing.html">OpenCV...</a> 


<br />



  		
  	    </div>
          </div>
        </div>
      </div> <!-- / section -->
    </div>
  </div>

  <br>
<br>
<br>
<br>

<div class="custom-disqus">
<!-- Disqus -->
<!-- Disqus disabled Oct 17, 2016 
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
     
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
---- Disable -->
<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br>


<!-- footer starts here -->
<footer id="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-4 widget">
        <h3 class="widget-title">Contact</h3>
        <div class="widget-body">
          <p>BogoToBogo<br>
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
          </p>  
        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title">Follow Bogotobogo</h3>
        <div class="widget-body">

          <!--
          <ul>
            <li><a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a></li>
            <li><a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a></li>
            <li><a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a></li>
          </ul>
          -->
             <h3>
             <a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a> 
             <a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a> 
             <a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a> 
             </h3>

        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title"><a href="../about_us.html">About Us</a></h3>
        <div class="widget-body">
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
            <br>
            Golden Gate Ave, San Francisco, CA 94115
          </p>  
        </div>
      </div>

    </div> 
  </div>
</footer>

<footer id="underfooter">
  <div class="container">
    <div class="row">
      
      <div class="col-md-6 widget">
        <div class="widget-body">
          <p>Golden Gate Ave, San Francisco, CA 94115 </p>
        </div>
      </div>

      <div class="col-md-6 widget">
        <div class="widget-body">
          <p class="text-right">
            Copyright &copy; 2016, bogotobogo<br> 
            Design: <a href="../index.html" rel="designer">Web Master</a> </p>
        </div>
      </div>

    </div>
  </div>
</footer>

  <!-- JavaScript libs are placed at the end of the document so the pages load faster -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script type="text/javascript"
     src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- D3.js -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<!-- Google Analytics -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-12016988-2']);
    _gaq.push(['_trackPageview']);
    
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

<!-- Google Analytics --> 
<!-- We need this for Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43017326-1', 'bogotobogo.com');
  ga('send', 'pageview');

</script>
  
<!-- Google+ -->
<script type="text/javascript" src="http://apis.google.com/js/plusone.js"></script>

</body>

<!-- Mirrored from www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11B.php by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 11 Dec 2017 15:00:55 GMT -->
</html>

