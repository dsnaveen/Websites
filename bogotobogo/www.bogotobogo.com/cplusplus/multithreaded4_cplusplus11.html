<!DOCTYPE html>

<!-- Mirrored from www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 10 Dec 2017 17:26:29 GMT -->
<head>
  <title>C++ Tutorial: Multi-Threaded Programming - C++11 A- 2017</title>
  <meta content="C++ Tutorial: Multi-Threaded Programming C++11 A" name="description" />
  <meta content="C++11 Tutorial, Multi-Threaded Programming , MultiThreading Programming, join(), start(), wait, 
  C++11, Spawning Threads Using Container, Ownership Transfer, Callable with Arguments, Background Threads,
Resource Acquisition Is Initialization (RAII), hardware_ concurrency()" name="keywords" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
  <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
  <link rel="stylesheet" href="../public/css/app.css">
  <link rel="stylesheet" href="../public/css/styles.css">
  <link rel="stylesheet" href="../public/css/bogostyleWidePreNew.css">
</head>

<body class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
    <div class="container-fluid">      
      <div class="navbar-header">
        <!--<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> -->
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar"> 
          <span class="sr-only">Toggle navigation</span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
        </button>
        <a class="navbar-brand" href="../index-2.html">BogoToBogo</a>
      </div>
      
      <div class="navbar-collapse collapse">
        
        <ul class="nav navbar-nav">
          <li class="active"><a href="../index-2.html">Home</a></li>
          <li><a href="../about_us.html">About</a></li>
          <li><a href="../Hadoop/BigData_hadoop_Install_on_ubuntu_single_node_cluster.html">Big Data</a></li>
          <li><a href="../python/scikit-learn/Artificial-Neural-Network-ANN-1-Introduction.html">Machine Learning</a></li>
          <li><a href="../AngularJS/AngularJS_Introduction.html">AngularJS</a></li> 
          <li><a href="../python/pytut.html">Python</a></li>
          <li><a href="cpptut.html">C++</a></li>
          <li><a href="../DevOps/DevOps_Jenkins_Chef_Puppet_Graphite_Logstash.html">DevOps </a></li>
          <li><a href="../Algorithms/algorithms.html">Algorithms</a></li> 
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">More...<b class="caret"></b></a>
            <ul class="dropdown-menu">
           
              <li><a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5</a></li>                           
              <li><a href="../Android/android.html">Android</a></li>
              
              <li><a href="../Linux/linux_tips1.html">Linux</a></li>
              <li><a href="../Java/tutorials/on_java.html">Java</a></li>
              <li><a href="../CSharp/.netframework.html">CSharp</a></li>
              <li><a href="../VideoStreaming/videostreaming_etc.html">Video Streaming</a></li>
              <li><a href="../FFMpeg/ffmpeg_fade_in_fade_out_transitions_effects_filters_slideshow_concat.html">FFmpeg</a></li>
              <li><a href="../Matlab/Matlab_Tutorial_Manipulating_Audio_I_Reverse_Delay_Tone_Control_Changing_Speed_Removing_Vocals.html">Matlab</a></li>
              <li><a href="../python/Django/Python_Django_Forums_Shared_Host.html">Django 1.8</a></li>
              <li><a href="../Laravel5/Laravel5_ToDo_List_Sample.html">Laravel 5.2</a></li>
              <li><a href="../RubyOnRails/RubyOnRails.html">Ruby On Rails</a></li>
              <li><a href="../HTML5/HTML5_Tutorial.html">HTML5 & CSS</a></li>
              <li><a href="../AmazingPlaces/index.html" target="_blank">
<img src="../Menus/MenuIcons/Earth_8px_transparent_background.png"
width="24" height="24"/>Earth</a> </li>
            </ul>
          </li>
        </ul>      
      </div>
    </div>  
  </nav>  

  <div id="main">
    <div class="container">
      <div class="row section featured topspace">
        <div class="row">
          <div class="col-sm-9 col-md-9 col-xs-9">
            <h2 class="section-title">
Multi-Threaded Programming 
with C++11 - Part A      <g:plusone></g:plusone></h2>
            <div class="icon-image">
                 <img src="images/cplusplus_icon.png" alt="cplusplus_icon.png"/>
            </div>
            <div class="SocialLinks">
  <span class='st__large' displayText=''></span>
  <br><br>
  <div align="center">
  <span class='st_facebook_large' displayText='Facebook'></span>
  <span class='st_twitter_large' displayText='Tweet'></span>
  <span class='st_linkedin_large' displayText='LinkedIn'></span>
  </div>
  <br><br>
  <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
  <script type="text/javascript">stLight.options({publisher: "b9569c43-5f56-4501-92f0-4bf4aa8fceb0", doNotHash: false, doNotCopy: true, hashAddressBar: false});</script>
</div>

<div id="bookmarkshare">
  <script type="text/javascript">var addthis_config = {"data_track_clickback":true};</script>
  <a class="addthis_button" href="http://www.addthis.com/bookmark.php?v=250&amp;username=khhong7"><img src="http://s7.addthis.com/static/btn/v2/lg-share-en.gif" width="125" height="16" alt="Bookmark and Share" style="border:0"/></a>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#username=khhong7"></script>
</div>

<br>
<hr>
<br>


<!-- Google bogo1 ad -->
<!-- Google search box -->



<!-- bogo1 -->
<div>
  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo1 -->
  <ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4716428189734495"
     data-ad-slot="6542308167"></ins>
  <script>
   (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


<!-- Google search box -->
<div class="AdSenseSearch">
  bogotobogo.com site search:
  <form action="http://www.google.com/" id="cse-search-box" target="_blank">
    <div>
      <input type="hidden" name="cx" value="partner-pub-4716428189734495:1794050961" />
      <input type="hidden" name="ie" value="UTF-8" />
      <!--<input type="text" name="q" size="55" />-->
      <input type="text" name="q" size="" width="90%"/>
      <input type="submit" name="sa" value="Search" />
    </div>
  </form>
  <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
</div>




<hr>
            <br><br><br>
<div class="subtitle" id="mthread4">Multi-Threaded Programming: C++11</div>
<br/>
<div class="subtitle_2nd" id="simplest">The simplest C++11 Multithread</div>

<!-- Google bogo_square_ad -->
<div>
  <script type="text/javascript">
    google_ad_client = "ca-pub-4716428189734495";
    /* bogo_LargeRectangle_336_280 */
    google_ad_slot = "2712696561";
    google_ad_width = 336;
    google_ad_height = 280;
  </script>
  <script type="text/javascript"
    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
  </script>
</div>
<br>





<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

void foo() { std::cout &lt;&lt; "foo()\n"; }
void bar() { std::cout &lt;&lt; "bar()\n"; }

int main()
{
	std::thread t(<font color="red">[]{
		        foo();
			bar();						 
	                }</font>);
	return 0;
}
</pre>
<br/>

<p>Once our thread started, we should let the code know if we want to wait for it to
finish by <strong>joining</strong> with it or leave it to run on its own by <strong>detaching</strong>
it. Our program may be terminated before the <strong>std::thread</strong> object is destroyed if we don't do anything explicitly.</p>
<p>So, we need to ensure that the thread is joined or
detached. If we choose not to wait the thread finish, then we need to ensure that the data
accessed by the thread is valid until the thread has finished with it. Otherwise, as shown in the example below, we may encounter a situation where the thread
function holds pointers/references to local variables and the thread hasn't finished when the function exits.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void foo(int i) { cout &lt;&lt; "foo() i = " &lt;&lt; i &lt;&lt; endl; }

struct task_struct
{
	int&amp; i;

	task_struct(int&amp; ii):i(ii){ 
		cout &lt;&lt; "task_struct constructor i = " &lt;&lt; i &lt;&lt; endl;
	}

	void operator()()
	{
		for(unsigned j = 0; j &lt; INT_MAX; ++j)
		{
			cout &lt;&lt; j &lt;&lt; ": foo()\n";
			foo(i);
		}
	}
};

void A_function_creating_a_thread_within()
{
	int state = 99;
	task_struct task(<font color="red">state</font>);

	cout &lt;&lt; "Launching a thread\n";
	std::thread t(task);

	cout &lt;&lt; "detaching the thread\n";
        // <font color="blue">do not wait for the thread to finish</font>
	<font color="red">t.detach();</font>
}

int main()
{
	A_function_creating_a_thread_within();
	cout &lt;&lt; "END OF PROGRAM\n";
	return 0;
}
</pre>
<p>with the possible output:</p>
<pre>
task_struct constructor i = 99
Launching a thread
0: foo()
foo() i = 99
detaching the thread
1: foo()
foo() i = 3996880
2: foo()
foo() i = 3996880
END OF PROGRAM
</pre>
<p>In the example, the new thread associated with <strong>t</strong> will probably still be running
when <strong>main()</strong> exits, because we explicitly decided not to wait for it by calling
<strong>detach()</strong>. </p>
<p>Following pictures are from Visual Studio 2012:</p>
<br/><br/>
<img alt="cppDebugA.png" src="images/multithread_cpp11A/cppDebugA.png"/>
<br/><br/><br/><br/>
<img alt="cppDebugB.png" src="images/multithread_cpp11A/cppDebugB.png"/>
<br/><br/><br/><br/>
<img alt="cppDebugC.png" src="images/multithread_cpp11A/cppDebugC.png"/>
<br/><br/><br/><br/>
<p>We can also check the thread variables: right click on the thread, and then "Switch To Thread".</p>
<img alt="cppDebugD.png" src="images/multithread_cpp11A/cppDebugD.png"/>
<br/><br/>
<p>Then, we can see the locals of the thread.</p>
<p>If the thread is still running, then the next call to <strong>foo(i)</strong> 
will access an already destroyed variable. 
In general, it's not a good idea to create a thread within a function accessing the local variables
in that function, unless the thread is guaranteed to finish before the function exits, which may not be the case for the example above.</p>
<p>We can avoid this problem by calling <strong>join()</strong> on the associated
<strong>std::thread instance</strong> so that we can wait for a thread to complete. 
</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="thread_join">join()</div>
<p>In the code below, we replaced the <strong>detach()</strong> with <strong>join()</strong> to ensure that the thread was finished before the function
was exited and thus before the local variables were destroyed. For more info on join, please visit <a href="multithreaded.html#Join" target="_blank">multithreaded-Join()</a>.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void foo(int i) { cout &lt;&lt; "foo() i = " &lt;&lt; i &lt;&lt; endl; }

struct task_struct
{
	int&amp; i;

	task_struct(int&amp; ii):i(ii){ 
		cout &lt;&lt; "task_struct constructor i = " &lt;&lt; i &lt;&lt; endl;
	}

	void operator()()
	{
		for(unsigned j = 0; j &lt; INT_MAX; ++j)
		{
			cout &lt;&lt; j &lt;&lt; ": foo()\n";
			foo(i);
		}
	}
};

void A_function_creating_a_thread_within()
{
	int state = 99;
	task_struct task(state);
	cout &lt;&lt; "Launching a thread\n";
	std::thread t(task);
	// cout &lt;&lt; "detaching the thread\n";
	// t.detach();
	cout &lt;&lt; "joining the thread\n";
	<font color="red">t.join();</font>
}

int main()
{
	A_function_creating_a_thread_within();
	cout &lt;&lt; "END OF PROGRAM\n";
	return 0;
}
</pre>
<p>
However, we can call 
<strong>join()</strong> only once for a given thread. Let's look inside the <strong>std::thread</strong> code:
<pre>
inline void thread::join()
	{	// join thread
	if (!<font color="red">joinable()</font>)
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	if (_Thr_is_null(_Thr))
		_Throw_Cpp_error(_INVALID_ARGUMENT);
	if (get_id() == _STD this_thread::get_id())
		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);
	if (_<font color="red">Thrd_join(_Thr, 0)</font> != _Thrd_success)
		_Throw_Cpp_error(_NO_SUCH_PROCESS);
	_Thr_set_null(_Thr);
	}
</pre>
Once <strong>join()</strong> is called, the <strong>std::thread</strong>
object is no longer joinable, and <strong>joinable()</strong> will return false.</p>
<p>The <strong>join()</strong> gives us no choice but to <strong>wait for a thread to finish</strong>. 
If we need more control over our waiting for a thread, such as to
check whether a thread is finished, or to wait only a certain period of time, then we
have to use <strong>condition variables</strong>. </p>
<p>Actuallu, calling <strong>join()</strong>) cleans up any storage associated
with the thread, so the <strong>std::thread</strong> object is no longer associated with the just finished
thread.</p>
<br/>
<p>When we call <strong>join()</strong> or
<strong>detach()</strong>, it should be done before a <strong>std::thread</strong> object is destroyed. 
If we're detaching a thread, we 
can usually call <strong>detach()</strong> immediately after the thread has been started, so this can't be an issue. 
However, if we want to wait for the thread, we need to be very careful regarding the 
place in the code where we put the call <strong>join()</strong>. In other words, the call to <strong>join()</strong> has a high chance of 
being skipped if an exception is thrown after the thread has been started but before the
call to <strong>join()</strong>.</p>
<p>To avoid our application being terminated when an exception is thrown, we may want to call <strong>join()</strong> in the non-exceptional case, and we also need to call <strong>join()</strong> in
the presence of an exception not to encounter accidental lifetime problems. As an example, let's look at the following code:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void foo(int i) { cout &lt;&lt; "foo() i = " &lt;&lt; i &lt;&lt; endl; }

struct task_struct
{
	int&amp; i;

	task_struct(int&amp; ii):i(ii){ 
		cout &lt;&lt; "task_struct constructor i = " &lt;&lt; i &lt;&lt; endl;
	}

	void operator()()
	{
		for(unsigned j = 0; j &lt; INT_MAX; ++j)
		{
			cout &lt;&lt; j &lt;&lt; ": foo()\n";
			foo(i);
		}
	}
};

void current_thread_task() 
{ 
	cout &lt;&lt; "try: current_thread_task()\n"; 
}


void A_function_creating_a_thread_within()
{
	int state = 99;
	task_struct task(state);

	std::thread t(task);

	<font color="red">try</font>
	{
		current_thread_task();
	}
	<font color="red">catch(...)</font>
	{
		cout &lt;&lt; "catch(...)\n";
                <font color="red">t.join();</font>
		throw;
	}
	<font color="red">t.join();</font>
}

int main()
{
	A_function_creating_a_thread_within();
	cout &lt;&lt; "END OF PROGRAM\n";
	return 0;
}
</pre>
<p>Output should look something like this:</p>
<pre>
task_struct constructor i = 99
0: foo()
try: current_thread_task()
foo() i = 99
1: foo()
foo() i = 99
2: foo()
foo() i = 99
3: foo()
foo() i = 99
4: foo()
foo() i = 99
...
END OF PROGRAM
</pre>
<p>The code is using a <strong>try/catch</strong> block to ensure that a thread with access to
local state is finished before the function exits, regardless of how the function exits either normally 
or by an exception. However, if it's important to ensure that
the thread must complete before the function exits and it's important to make sure that 
this is the case for all possible exit paths, and it's
desirable to provide a simple way of doing it.</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="raii">Resource Acquisition Is Initialization
(RAII)</div>
<p><strong>Resource Acquisition Is Initialization
(RAII)</strong> provides a class that does the <strong>join()</strong> in its destructor, as shown in the following
code. </p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void foo(int i) 
{
	cout &lt;&lt; "foo(" &lt;&lt; i &lt;&lt; ")\n";
}

struct task_struct
{
	int&amp; i;
	task_struct(int&amp; ii):i(ii){ "task_struct constructor\n";}
	void operator()()
	{
		cout &lt;&lt; "task_struct::operator()\n";
		for(unsigned j = 0; j &lt; 10; ++j)
		{
			foo(i);
		}
	}
};

class thread_RAII
{
	thread&amp; t;
public:
	thread_RAII(thread&amp; th):t(th)
	{
		cout &lt;&lt; "thread_RAII constructor\n";
	}

	~thread_RAII()
	{
		if(<font color="red">t.joinable()</font>) 
		{
			cout &lt;&lt; "if joinable(), then t.join()\n";
			<font color="red">t.join();</font>
		}
		cout &lt;&lt; "thread_RAII destructor\n";
	}

private:
	// copy constructor
	thread_RAII(const thread_RAII&amp; thr) ;

	// copy-assignment operator
	thread_RAII&amp; operator=(const thread_RAII&amp; thr);
};

void current_thread_task()
{
	cout &lt;&lt; "do something in current_thread_task()\n";
};

void A_function_creating_a_thread_within()
{
	int state = 99;
	task_struct task(state);
	cout &lt;&lt; "launching a thread\n";
	thread t(task);
	cout &lt;&lt; "make an instance of thead_RAII\n";
	thread_RAII raii(t);
	cout &lt;&lt; "call current_thread_task()\n";
	current_thread_task();
}

int main()
{
	A_function_creating_a_thread_within();
	return 0;
}
</pre>
<p>The output can be random:</p>
<pre>
launching a thread
task_struct::operator()
foo(make an instance of thead_RAII
thread_RAII constructor
call current_thread_task()
do something in current_thread_task()
if joinable(), then t.join()
99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
thread_RAII destructor
</pre>
<p>When the execution of the current thread reaches the end of <strong>A_function_creating_a_thread_within()</strong> , the local objects are destroyed in reverse order of construction. In other words, the <strong>thread_RAII</strong> 
object <strong>raiiObj</strong> is destroyed first. The next one to be destroyed is <strong>t</strong>.</p>
<p>The destructor of <strong>thread_RAII</strong> first tests to see if the <strong>std::thread</strong>
object is <strong>joinable()</strong> before calling <strong>join()</strong>. This is important, because <strong>join()</strong>
can be called only once for a given thread of execution, so it would therefore be a mistake
to do so if the thread had already been joined.</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="background">Background Threads</div>
<p>Calling <strong>detach()</strong> on a <strong>std::thread</strong> object leaves the thread to run in the <strong>background</strong>. The actual thread of execution has no direct communication with the detached thread, thus there is no control over    waiting for that thread to complete. In other words, if a thread becomes detached, it's impossible to obtain that  
<strong>std::thread</strong> object, so it can no longer be joined. A detached thread runs in the background. The ownership and control are passed over to the C++ Runtime
Library. The C++ Runtime Library ensures that the resources of the thread are correctly
reclaimed when the thread exits.</p>
<p>Detached threads are also called <strong>daemon threads</strong>. The daemon threads may well run for almost the entire lifetime of the application, performing a background task such as monitoring the filesystem,
clearing unused entries out of object caches, or optimizing data structures, etc. </p>
<pre>
std::thread t(background_task);
t.detach();
assert(!t.joinable());
</pre>
<p>In order to detach the thread from a std::thread object, there must be a thread to
detach: we can't just call <strong>detach()</strong> on a <strong>std::thread</strong> object with no associated thread of execution. This is exactly the same situation as for <strong>join()</strong>, and we can check it in
exactly the same way: we can only call <strong>t.detach()</strong> for a <strong>std::thread</strong> object <strong>t</strong> when
<strong>t.joinable()</strong> returns true.</p>
<p>Suppose we have an application that can edit several documents. Whenever we open a new document to edit, we can create a thread and edit the document on that thread. Each document is running on an independent thread, and thus there is no need for waiting. Here is the example:</p>
<pre>
void <font color="red">editDocument</font>(std::string const&amp; fileName)
{
	openDocumentAndDisplayGUI(fileName);
	while(!doneEditing())
	{
		UserCommand cmd=getUserInput();
		if(cmd.type==openNewDocument)
		{
			std::string const newName=getFilename();
			std::thread t(<font color="red">editDocument</font>,newName);
			<font color="red">t.detach();</font>
		}
		else
		{
			processUserInput(cmd);
		}
	}
}
</pre>
<p>If the user tries to open a new document, we prompt them for the document to
open, start a new thread to open that document, and then detach it. Note that because the new thread is doing the same task as the current thread but on a different
file, we can reuse the same function (<strong>editDocument</strong>) with the newly chosen <strong>fileName</strong>
as the supplied argument.</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="callable_args">Callable with Arguments</div>
<p>We can pass arguments to the callable object or function. It is 
as simple as passing additional arguments to the <strong>std::thread</strong> constructor.
However, it's important to note that the arguments are copied into internal
storage, where they can be accessed by the newly created thread.</p>
<p>The following example creates a new thread <strong>t</strong> which calls <strong>t(CallableObj, 3.14, "pi")</strong>.</p>
<pre>
void CallableObj(double d, std::string const&amp; s);
std::thread t(CallableObj, 3.14, "pi");
</pre>
<p>Note that even though <strong>CallableObj</strong> takes a <strong>string</strong> as the second parameter, the string literal
is passed as a <strong>char const*</strong> and converted to a <strong>string</strong> only in the context of
the new thread. This is important when the argument we supply is a 
<strong>pointer to an automatic variable</strong>:</p>
<pre>
void CallableObj(double d, std::string const&amp; s);

void fnc(float param)
{
	char buf[1024];
	sprintf(<font color="red">buf</font>, "%f", param);
	thread t(CallableObj, 3.14, <font color="red">buf</font>);
	t.detach();
}
</pre>
<p>In this case, it's the pointer to the local variable <strong>buf</strong> that was passed through to the
new thread, and there's a significant chance that the function <strong>fnc</strong> will exit before
the buffer has been converted to a <strong>string</strong> on the new thread, thus may cause 
undefined behavior.</p>
<p>To avoid the undefined behavior, we can cast it to <strong>string</strong> before passing the <strong>buf</strong>
to the <strong>std::thread</strong> constructor:</p>
<pre>
void CallableObj(double d, std::string const&amp; s);

void fnc2(float param)
{
	char buf[1024];
	sprintf(buf, "%f", param);
	thread t(CallableObj, 3.14, <font color="red">string</font>(buf));
	t.detach();
}
</pre>
<p>In the example above, the potential issue is that we are relying on the implicit conversion of the
pointer to the <strong>buf</strong> into the <strong>string</strong> object as a function parameter,
because the thread constructor copies the supplied values as it is, without converting
to the expected argument type.</p>
<p>It's also possible to get the reverse scenario. That is, the object is copied, and what we 
wanted is a reference. This might happen if the thread is updating a data structure
that's passed in by reference. Here is the example of that case:</p>
<pre>
void updateWidgetData(Widget w, WidgetData&amp; wData);

void fnc3(Widget w)
{
       WidgetData data;
       std::thread t(updateWidgetData, w, data);
       displayStatus();
       t.join();
       processWidgetData(data);
}
</pre>
<p>Although <strong>updateWidgetData</strong> expects the second parameter to be passed by
reference, the <strong>std::thread</strong> constructor doesn't aware of that. It's oblivious to the
types of the arguments expected by the function and blindly copies the supplied values.
When it calls <strong>updateWidgetData</strong>, it will end up passing a reference to
the internal copy of data and not a reference to data itself. Consequently, when the
thread finishes, these updates will be discarded as the internal copies of the supplied
arguments are destroyed, and <strong>processWidgetData()</strong> will be passed an unchanged
data rather than a correctly updated version. </p>
<p>The solution is to wrap the arguments that
really need to be references in <strong>std::ref</strong></p>
<pre>
void updateWidgetData(Widget w, WidgetData&amp; wData);

void fnc4(Widget w)
{
       WidgetData data;
       std::thread t(updateWidgetData, w, <font color="red">std::ref(data)</font>);
       displayStatus();
       t.join();
       processWidgetData(data);
}
</pre>
<p>Then, <strong>updateWidgetData</strong> will be correctly passed a <strong>reference</strong> to <strong>data</strong> rather
than a reference to a copy of <strong>data</strong>.<p>
<p>The parameter-passing semantics is similar to <strong>std::bind</strong>.
In both cases, the operation of the <strong>std::thread</strong> constructor and the operation
of <strong>std::bind</strong> are defined in a similar manner. This means that we can pass a function pointer as the function, provided we supply
a suitable object pointer as the first argument:</p>
<pre>
class X
{
public:
       void task();
};

X x;
std::thread t(&amp;X;::task, &amp;x;);
</pre>
<p>This code will invoke <strong>x.task()</strong> on the new thread, because the
address of <strong>x</strong> is supplied as the object pointer. We can also supply arguments to
such a member function call: the third argument to the <strong>std::thread</strong> constructor will
be the first argument to the member function and so forth.</p>
<p>Another interesting scenario for supplying arguments is where the arguments
can't be copied but can only be moved: the data held within one object is transferred
over to another, leaving the original object empty. An example of such a type is
<strong>std::unique_ptr</strong>, which provides automatic memory management for dynamically
allocated objects. Only one <strong>std::unique_ptr</strong> instance can point to a given object at a
time, and when that instance is destroyed, the pointed-to object is deleted.</p>
<p> The <strong>move
constructor</strong> and <strong>move assignment operator</strong> allow the ownership of an object to be transferred
around between <strong>std::unique_ptr</strong> instances. Such a transfer leaves the source object with a <strong>NULL</strong>
pointer. This moving of values allows objects of this type to be accepted as function
parameters or returned from functions. If the source object is a temporary, the
move is automatic, however, if the source is a named value, the transfer must be
requested directly by invoking <strong>std::move()</strong>.</p>
<p>The example below shows the use of
<strong>std::move</strong> to <strong>transfer ownership</strong> of a dynamic object into a thread:</p>
<pre>
void processObject(std::unique_ptr&lt;object&gt;);
<font color="red">std::unique_ptr</font>&lt;object&gt; p(new object);
p-&gt;prepareData(99);
std::thread t(processObject, <font color="red">std::move(p)</font>);
</pre>
<p>By specifying <strong>std::move(p)</strong> in the std::thread constructor, the ownership of the
<strong>object</strong> is transferred first into internal storage for the newly created thread and
then into <strong>processObject</strong>.</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="ownership_transfer">Ownership Transfer</div>
<p>The <strong>std::unique_ptr</strong>'s ownership semantics is the same as that of <strong>std::thread</strong>. Though <strong>std::thread</strong> 
instance doesn't own a dynamic object in the same way as <strong>std::unique_ptr</strong> does, it
 owns a resource. In other words, each instance is responsible for managing a thread of execution.
This ownership can be transferred between instances, because instances of <strong>std::thread</strong>
are <strong>movable</strong>, even though they aren't <strong>copyable</strong>. Therefore, only one object is associated
with a particular thread of execution at any one time while providing programmers
 with the option of transferring the ownership between objects.</p>
<p>There are couple of situations that we want to move ownership to another thread. 
Suppose we want to write a function that creates a thread to run in the background. But we want 
 the ownership of the new thread to pass back to the calling function rather than waiting
for it to complete. In another case, we create a thread and pass the 
ownership to some function that should wait for it to complete. For both cases, we
need to transfer ownership from one place to another.</p>
<p>This is why <strong>std::thread</strong> needs to support the move. 
Many resource-owning types in the C++ Standard Library such as 
<strong>std::ifstream</strong> and <strong>std::unique_ptr</strong> are movable but not copyable, 
and <strong>std::thread</strong> is
one of them. This means that the ownership of a particular thread of execution can
be moved between <strong>std::thread</strong> instances, as shown in the following code.</p>
<p>It creates two threads of execution and transfers ownership of those
threads among three std::thread instances, <strong>t1</strong>, <strong>t2</strong>, and <strong>t3</strong>:
</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void f1() { cout &lt;&lt; "f1()\n"; }
void f2() { cout &lt;&lt; "f2()\n"; }


int main()
{
	// <font color="blue">a new thread is started and associated with t1</font>
	thread t1(f1);   // (A)

	// <font color="blue">Ownership is then transferred over to t2 </font>
	// <font color="blue">and moves ownershipby when t2 is constructed</font>
	thread t2 = move(t1);   // (B)

	// <font color="blue">Now, t1 no longer has any associated thread of execution; </font>
	// <font color="blue">the thread running f1 is now associated with t2.</font>

	// <font color="blue">A new thread is started and associated with a temporary thread object</font>
	// <font color="blue">The transfer of ownership into t1 doesn't require a call to move() to explicitly move ownership,</font> 
	// <font color="blue">because the owner is a temporary object-moving from temporaries is automatic and implicit.</font>
	t1 = thread(f2);   // (C)

	// <font color="blue">t3 is default constructed.</font>
	// <font color="blue">This means that it's created without any associated thread of execution.</font>
	thread t3;   // (D)

	// <font color="blue">Ownership of the thread currently associated with t2 is transferred into t3.</font>
	// <font color="blue">This time, with an explicit call to std::move(), because t2 is a named object. </font>
	// <font color="blue">After all these moves, t1 is associated with the thread running f2, </font>
	// <font color="blue">t2 has no associated thread, and t3 is associated with the thread running f1.</font>
	t3 = move(t2);   // (E)

	// <font color="blue">The final move transfers ownership of the thread running f1 back to t1 where it started. </font>
        // <font color="blue">This assignment will terminate program!</font>
	t1 = move(t3);   // (F)
                         // (G)
	return 0;
}
</pre>
<p>The following pictures show the creation and the movement of the threads from (A) to (G). Each represents the line of execution, for example, (A) means that the debugging session is at the line and about to execute that line of code:</p>
<p>(A) The line of code: thread t1(f1); is about to be executed;</p>
<img alt="MoveA1.png" src="images/multithread_cpp11A/MoveA1.png"/>
<br/><br/>
<img alt="MoveA2.png" src="images/multithread_cpp11A/MoveA2.png"/>
<br/><br/>
<p>(B) After execution of the line: thread t1(f1);</p>
<img alt="MoveB1.png" src="images/multithread_cpp11A/MoveB1.png"/>
<br/><br/>
<img alt="MoveB2.png" src="images/multithread_cpp11A/MoveB2.png"/>
<br/><br/>
<p>(C) After execution of the line: thread t2 = move(t1);</p>
<img alt="MoveC2.png" src="images/multithread_cpp11A/MoveC2.png"/>
<br/><br/>
<p>(D) After execution of the line: t1 = thread(f2);</p>
<img alt="MoveD2.png" src="images/multithread_cpp11A/MoveD2.png"/>
<br/><br/>
<p>(E) After execution of the line: thread t3;</p>
<img alt="MoveE2.png" src="images/multithread_cpp11A/MoveE2.png"/>
<br/><br/>
<p>(F) After execution of the line: t3 = move(t2); </p>
<img alt="MoveF2.png" src="images/multithread_cpp11A/MoveF2.png"/>
<br/><br/>
<p>(G) After execution of the line: t1 = move(t3);</p>
<img alt="MoveG2.png" src="images/multithread_cpp11A/MoveG2.png"/>
<br/><br/>
<p>One thing for the last <strong>move()</strong> (G): </p>
<pre>
t1 = move(t3);
</pre>
we must explicitly wait for a thread to complete or detach it before
destruction, and the same applies to assignment. In this case <strong>t1</strong> already had an associated thread (which was running <strong>f2</strong>). Therefore, <strong>terminate()</strong> is called to terminate the program. This is done for consistency with the <strong>std::thread destructor</strong>. We can't just <strong>drop</strong> a thread by
assigning a new value to the <strong>std::thread</strong> object that manages it.</p>
<br/>
<p>The support for <strong>move</strong> in <strong>std::thread</strong> means that ownership can readily be transferred
out of a <strong>function</strong>:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void fnc1() { cout &lt;&lt; "fnc1()\n"; }
void fnc2(int i) { cout &lt;&lt; "fnc2(int " &lt;&lt; i &lt;&lt; ")\n"; }

thread f()
{
	return <font color="red">thread(fnc1)</font>;
}

thread g()
{
	thread t(fnc2, 999);
	return <font color="red">t</font>;
}

int main()
{
	// two threads are started within functions f() and g()
	<font color="red">f()</font>.join();
	<font color="red">g()</font>.join();

	return 0;
}
</pre>
<p>Output from the run is:</p>
<pre>
fnc1()
fnc2(int 999)
</pre>
<br/>
<p>If ownership should be transferred <strong>into a function</strong>, it can just accept an
instance of thread by <strong>value</strong> as one of the parameters:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void fnc() 
{ 
	cout &lt;&lt; "thread task fnc()\n"; 
}

void f(thread t) 
{
	cout &lt;&lt; "f(thread t)\n";
	t.join();
}

void g()
{
	f(<font color="red">thread(fnc)</font>);
	thread t(fnc);
	f(<font color="red">move(t)</font>);
}

int main()
{
	g();
	return 0;
}
</pre>
<p>Output should look like this:</p>
<pre>
f(thread t)
thread task fnc()
f(thread t)
thread task fnc()
</pre>
<br/>
<p>One of the benefits of the move support of <strong>std::thread</strong> is that we can build on the
<a href="#raii">thread_RAII</a> class of the previous example and have it actually take ownership of the thread.
This avoids any unpleasant consequences should the <strong>thread_RAII</strong> object outlive the
thread it was referencing, and it also means that no one else can join or detach
the thread once ownership has been transferred into the object: <a href="files/multithread_cpp11A/MyThread.cpp" target="_blank">source file - MyThread.cpp</a></p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

void foo(int i) 
{
	cout &lt;&lt; "foo(" &lt;&lt; i &lt;&lt; ")\n";
}

struct task_struct
{
	int&amp; i;
	task_struct(int&amp; ii):i(ii)
	{
		cout &lt;&lt; "constructor for task_struct\n";
	}

	void operator()()
	{
		cout &lt;&lt; "task_struct::operator()\n";
		for(unsigned j = 0; j &lt; 10; ++j)
		{
			foo(i);
		}
	}
};

class MyThread
{
	thread t;
public:
	explicit MyThread(thread&amp; th):t(move(th))
	{
		// <font color="blue">Checking the thread is still joinalbe in the constructor </font>
		// <font color="blue">and throw an exception if it's not.</font>
		if(!t.joinable()) 
                       throw std::logic_error( "Not joinable" );
		cout &lt;&lt; "MyThread constructor\n";
	}

	~MyThread()
	{
		// <font color="blue">joins with the thread supplied to the constructor t.join();</font>
		// <font color="blue">do not need to joinable check. </font>
		// <font color="blue">if(t.joinable()) t.join();</font>
                t.join();
		cout &lt;&lt; "MyThread destructor\n";
	}

	// <font color="blue">copy constructor</font>
	MyThread(MyThread const&amp;) ;

	// <font color="blue">copy-assignment operator</font>
	MyThread&amp; operator=(MyThread const&amp;);
};

void current_thread_task()
{
	cout &lt;&lt; "do something in current_thread_task()\n";
};

void f()
{	
	int state = 99; // <font color="blue">local state variable</font>

	task_struct task(state);
	thread t(task);

	MyThread mt(t);

	current_thread_task();
	//<font color="blue"> When the initial thread reaches this point, </font>
	//<font color="blue"> the object of MyThread is destroyed in ~MyThread()</font>
}

int main()
{
	f();

	return 0;
}
</pre>
<br/>
<p>Possible output from the run is:</p>
<pre>
constructor for task_struct
task_struct::operator()
MyThread constructor
do something in current_thread_task()
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
foo(99)
MyThread destructor
</pre>
<br/>
<br/><br/>
<br/>
<div class="subtitle_2nd" id="spawing_threads_using_container">Spawning Threads Using Container</div>
<p>The <strong>move</strong> in <strong>std::thread</strong> also allows containers to have <strong>std::thread</strong> 
objects, if those containers are <strong>move aware</strong> like the updated <strong>std::vector&lt;&gt;</strong>. This
means that we can write code which spawns a number
of threads and then waits for them to finish using container classes.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

void doTask(unsigned id) 
{
	cout &lt;&lt; "doTask()\n";
}

void f()
{
	vector&lt;thread&gt; threads;

	for(unsigned i = 0; i &lt; 10; ++i)
	{
		// spawn threads
		threads.push_back(thread(doTask, i));
	}

	// call join() on each thread in turn
	for_each(threads.begin(), threads.end(),
	                    std::mem_fn(&amp;thread;::join));
}

int main()
{
	f();
	return 0;
}
</pre>
<p>Output:</p>
<pre>
doTask()
doTask()
doTask()
doTask()
doTask()
doTask()
doTask()
doTask()
doTask()
doTask()
</pre>
<p>Putting <strong>std::thread</strong> objects in a <strong>std::vector&lt;&gt;</strong> is a step toward automating the
management of those threads. Instead of creating separate variables for those
threads and joining with them directly, they can be treated as a group.</p>
<br/>
<br/>
<br/>
<div class="subtitle_2nd" id="number_of_threads">Setting Number of Threads at Runtime</div>
<p>We can choose a dynamic number of threads at runtime rather than creating a fixed number as in the previous example.
</p>
<p><strong>std::thread::hardware_
concurrency()</strong> function returns an indication of the number of threads that can
 run concurrently for a given execution. It may be the number of cores on a multicore system and 
it can be used  for distributing tasks among threads.</p>
<p>The code below is a parallel version of <strong>std::accumulate</strong>.
It divides the work among the threads, with a minimum number of elements per
thread. </p>
<pre>
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

template&lt;typename Iterator, typename T&gt;
struct accumulate_block
{
	void operator()(Iterator first, Iterator last, T&amp; result)
	{
		result=std::accumulate(first, last, result);
	}
};

template&lt;typename Iterator, typename T&gt;
T parallel_accumulate(Iterator first, Iterator last, T init)
{
	unsigned long const length = std::distance(first, last);

        // <font color="blue">If the input range is empty, just return the initial value init.</font>
	if(!length) return init;

	unsigned long const min_per_thread = 50;

        // <font color="blue">Otherwise, there is at least one element in the range, </font>
        // <font color="blue">divide the number of elements to process by the minimum block size </font>
        // <font color="blue">in order to give the maximum number of threads</font>
	unsigned long const max_threads =
		(length+min_per_thread-1)/min_per_thread;

        // <font color="blue">std::thread::hardware_ concurrency() function returns the number of threads </font>
        // <font color="blue">that can run concurrently for a given execution.</font>
	unsigned long const hardware_threads =
	        thread::hardware_concurrency();

        // <font color="blue">The number of threads to run is the minimum of our calculated maximum and</font>
        // <font color="blue">the number of hardware threads</font>
        // <font color="blue">If the call to thread::hardware_concurrency() returned 0, we simply substitute it with 2.</font>
	unsigned long const num_threads =
		std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);

        // <font color="blue">The number of entries for each thread to process is </font>
        // <font color="blue">the length of the range divided by the number of threads</font>
	unsigned long const block_size = length / num_threads;

        // <font color="blue">To know how many threads we have, we can create a std::vector<t></t></font>
	vector&lt;T&gt; results(num_threads);

        // <font color="blue">Launch one fewer thread than num_threads, because we already have one.</font>
	vector&lt;thread&gt; threads(num_threads-1);

	Iterator block_start = first;

        // <font color="blue">Launching the threads with a loop </font>
	for(unsigned long i=0; i &lt; num_threads - 1; ++i)
	{
		Iterator block_end = block_start;

                // <font color="blue">advance the block_end iterator to the end of the current block</font>
		std::advance(block_end, block_size);

                // <font color="blue">launch a new thread to accumulate the results for the block</font>
		threads[i] = thread(accumulate_block&lt;Iterator, T&gt;(),
				block_start, block_end, std::ref(results[i]));
 
                // <font color="blue">The start of the next block is the end of this block</font>
		block_start = block_end;
	}

        // <font color="blue">After the launch of all the threads, </font>
        // <font color="blue">this thread can then process the final block</font>
	accumulate_block&lt;Iterator, T&gt;()(
	        block_start, last, results[num_threads-1]);

        // <font color="blue">Once accumulated the results for the last block, </font>
        // <font color="blue">we can wait for all the threads </font>
	std::for_each(threads.begin(), threads.end(),
				std::mem_fn(&amp;std;::thread::join));

        // <font color="blue">add up the results with a final call to std::accumulate</font>
	return std::accumulate(results.begin(), results.end(), init);
}
</pre>
<p>The number of threads to run is the minimum of our calculated maximum and
the number of hardware threads. We do not want to run more threads than the
hardware can support (<strong>oversubscription</strong>), because the context switching
will mean that more threads will decrease the performance.</p>
<p>Note: this chapter is largely based on "C++ Concurrency in Action Practical Multithreading by Anthony Williams"</p>
<br/>
<br/>
<br/>
</p>
<div>
    
<div class="custom-disqus">
<!-- Disqus -->
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
/* Disabling Disqus 4/26/2017
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
 Disabling Disqus */    
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br></div>
          </div>
          <div class="col-sm-3 col-md-3 col-xs-3">
  	    <div class="g-person" data-width="1" data-href="//plus.google.com/111664369941456137911" data-rel="author">
  	    </div>
            <div class="resume">
              <p>Ph.D. / Golden Gate Ave, San Francisco / Seoul National Univ / Carnegie Mellon / UC Berkeley / DevOps / Deep Learning / Visualization</p>
            </div>
  	    <div>
                
<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>




<!-- Place this tag after the last widget tag. -->
<script type="text/javascript">
        (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/platform.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
</script>
  	    </div>
  	    <div class="side_menu">
                <br /><br />

<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>

<!-- cplusplus_list_INNER.php -->
<br><br><br>
<h1>C++ Tutorials</h1>
   <a href="cpptut.html">C++ Home</a> 
   <br><br>
   <a href="../Algorithms/algorithms.html">Algorithms & Data Structures in C++ ...</a>
   <br><br>
   <a href="application_visual_studio_2013.html">Application (UI) - using Windows Forms (Visual Studio 2013/2012)</a>
   <br><br>
   <a href="autoptr.html">auto_ptr</a>
   <br><br>
   <a href="binarytree.html">Binary Tree Example Code</a>
   <br><br>
   <a href="blackjackQT.html">Blackjack with Qt</a>
   <br><br>
   <a href="boost.html">Boost - shared_ptr, weak_ptr, mpl, lambda, etc.</a>
   <br><br>
   <a href="Boost/boost_AsynchIO_asio_tcpip_socket_server_client_timer_A.html">Boost.Asio (Socket Programming - Asynchronous TCP/IP)...</a>
   <br><br>
   <a href="class.html">Classes and Structs</a> 
   <br><br>
   <a href="constructor.html">Constructor</a> 
   <br><br>
   <a href="cplusplus11.html">C++11(C++0x): rvalue references, move constructor, and lambda, etc.</a> 
   <br><br>
   <a href="cpptesting.html">C++ API Testing</a>
   <br><br>
   <a href="cplusplus_keywords.html">C++ Keywords - const, volatile, etc.</a>
   <br><br>
   <a href="CppCrashDebuggingMemoryLeak.html">Debugging Crash & Memory Leak</a>
   <br><br>
   <a href="../DesignPatterns/introduction.html">Design Patterns in C++ ...</a>
   <br><br>
   <a href="dynamic_cast.html">Dynamic Cast Operator</a>
   <br><br>
   <a href="eclipse_CDT_JNI_MinGW_64bit.html">Eclipse CDT / JNI (Java Native Interface) / MinGW</a>
   <br><br>
   <a href="embeddedSystemsProgramming.html">Embedded Systems Programming I - Introduction</a>
   <br><br>
   <a href="embeddedSystemsProgramming_gnu_toolchain_ARM_cross_compiler.html">Embedded Systems Programming II - gcc ARM Toolchain and Simple Code on Ubuntu and Fedora</a>
   <br><br>
   <a href="embeddedSystemsProgramming_GNU_ARM_ToolChain_Eclipse_CDT_plugin.html">Embedded Systems Programming III - Eclipse CDT Plugin for gcc ARM Toolchain </a>
   <br><br>
   <a href="exceptions.html">Exceptions</a> 
   <br><br>
   <a href="friendclass.html">Friend Functions and Friend Classes</a>
   <br><br>
   <a href="fstream_input_output.html">fstream: input & output</a>
   <br><br>
   <a href="function_overloading.html">Function Overloading</a>
   <br><br>
   <a href="functor_function_object_stl_intro.html">Functors (Function Objects) I - Introduction</a>
   <br><br>
   <a href="functor_function_object_stl_2.html">Functors (Function Objects) II - Converting function to functor</a>
   <br><br>
   <a href="functors.html">Functors (Function Objects) - General</a>
   <br><br>
   <br><br>
   <a href="Git/Git_GitHub_Express.html">Git and GitHub Express...</a>
   <br><br>
   <a href="google_unit_test_gtest.html">GTest (Google Unit Test) with Visual Studio 2012</a>
   <br><br>
   <a href="multipleinheritance.html">Inheritance & Virtual Inheritance (multiple inheritance) </a>
   <br><br>
   <a href="libraries.html">Libraries - Static, Shared (Dynamic)</a>
   <br><br>
   <a href="linked_list_basics.html">Linked List Basics</a>
   <br><br>
   <a href="linkedlist.html">Linked List Examples</a>
   <br><br>
   <a href="make.html">make & CMake</a>
   <br><br>
   <a href="gnumake.html">make (gnu)</a>
   <br><br>
   <a href="memoryallocation.html">Memory Allocation</a>
   <br><br>
   <a href="multithreaded.html">Multi-Threaded Programming - Terminology - Semaphore, Mutex, Priority Inversion etc.</a>
   <br><br>
   <a href="multithreading_win32A.html">Multi-Threaded Programming II -  Native Thread for Win32 (A) </a>
   <br><br>
   <a href="multithreading_win32B.html">Multi-Threaded Programming II -  Native Thread for Win32 (B) </a>
   <br><br>
   <a href="multithreading_win32C.html">Multi-Threaded Programming II -  Native Thread for Win32 (C) </a>
   <br><br>
   <a href="multithreading_win32.html">Multi-Threaded Programming II - C++ Thread for Win32</a>
   <br><br>
   <a href="multithreading_pthread.html">Multi-Threaded Programming III - C/C++ Class Thread for Pthreads</a>
   <br><br>
   <a href="multithreading_ipc.html">MultiThreading/Parallel Programming - IPC</a>
   <br><br>
   <a href="multithreaded4_cplusplus11.html">Multi-Threaded Programming with C++11 Part A (start, join(), detach(), and ownership)</a>
   <br><br>
   <a href="multithreaded4_cplusplus11B.html">Multi-Threaded Programming with C++11 Part B (Sharing Data - mutex, and race conditions, and deadlock)</a>
   <br><br>
   <a href="multithreadedDebugging.html">Multithread Debugging</a>
   <br><br>
   <a href="object_returning.html">Object Returning</a>
   <br><br>
   <a href="slicing.html">Object Slicing and Virtual Table</a>
   <br><br>
   <a href="opencv.html">OpenCV with C++</a> 
   <br><br>
   <a href="operatoroverloading.html">Operator Overloading I</a> 
   <br><br>
   <a href="operator_oveloading_self_assignment.html">Operator Overloading II - self assignment</a> 
   <br><br>
   <a href="valuevsreference.html">Pass by Value vs. Pass by Reference</a>
   <br><br>
   <a href="pointers.html">Pointers</a>
   <br><br>
   <a href="pointers2_voidpointers_arrays.html">Pointers II - void pointers & arrays</a>
   <br><br>
   <a href="pointers3_function_multidimensional_arrays.html">Pointers III - pointer to function & multi-dimensional arrays</a>
   <br><br>
   <a href="preprocessor_macro.html">Preprocessor - Macro</a>
   <br><br>
   <a href="private_inheritance.html">Private Inheritance</a>
   <br><br>
   <a href="../python/python_cpp_sip.html">Python & C++ with SIP</a>
   <br><br>
   <a href="RandomNumbers.html">(Pseudo)-random numbers in C++</a>
   <br><br>
   <a href="references.html">References for Built-in Types</a>
   <br><br>
   <a href="sockets_server_client.html">Socket - Server & Client</a>
   <br><br>
    <a href="sockets_server_client_QT.html">Socket - Server & Client with Qt (Asynchronous / Multithreading / ThreadPool etc.)</a>
   <br><br>
   <a href="stackunwinding.html">Stack Unwinding</a>
   <br><br>
   <a href="stl_vector_list.html">Standard Template Library (STL) I - Vector & List</a>
   <br><br>
   <a href="stl2_map.html">Standard Template Library (STL) II - Maps</a>
   <br><br>
   <a href="stl2_unorderd_map_cpp11_hash_table_hash_function.html">Standard Template Library (STL) II - unordered_map</a>
   <br><br>
   <a href="stl2B_set.html">Standard Template Library (STL) II - Sets</a>
   <br><br>
   <a href="stl3_iterators.html">Standard Template Library (STL) III - Iterators</a>
   <br><br>
   <a href="stl4_algorithms.html">Standard Template Library (STL) IV - Algorithms</a>
   <br><br>
   <a href="stl5_function_objects.html">Standard Template Library (STL) V - Function Objects</a>
   <br><br>
   <a href="statics.html">Static Variables and Static Class Members</a>
   <br><br>
   <a href="string.html">String</a> 
   <br><br>
   <a href="string2.html">String II - sstream etc.</a> 
   <br><br>
   <a href="assembly.html">Taste of Assembly</a>
   <br><br>
   <a href="templates.html">Templates</a>
   <br><br>
   <a href="template_specialization_function_class.html">Template Specialization</a>
   <br><br>
   <a href="template_specialization_traits.html">Template Specialization - Traits</a>
   <br><br>
   <a href="template_declaration_definition_header_implementation_file.html">Template Implementation & Compiler (.h or .cpp?)</a>
   <br><br>
   <a href="this_pointer.html">The this Pointer</a>
   <br><br>
   <a href="typecast.html">Type Cast Operators</a>
   <br><br>
   <a href="upcasting_downcasting.html">Upcasting and Downcasting</a>
   <br><br>
   <a href="virtual_destructors_shared_ptr.html">Virtual Destructor & boost::shared_ptr</a>
   <br><br>
   <a href="virtualfunctions.html">Virtual Functions</a>
   <br><br>
   <br><br>
   <i>Programming Questions and Solutions &darr;</i>
      <br><br>
       <a href="quiz_strings_arrays.html">Strings and Arrays</a>
       <br><br>
       <a href="quiz_linkedlist.html">Linked List</a>
       <br><br>
       <a href="quiz_recursion.html">Recursion</a>
       <br><br>
       <a href="quiz_bit_manipulation.html">Bit Manipulation</a> 
       <br><br>
       <a href="smallprograms.html">Small Programs (string, memory functions etc.)</a>
       <br><br>
       <a href="quiz_math_probability.html">Math & Probability</a>
       <br><br>
       <a href="quiz_multithreading.html">Multithreading</a>
       <br><br>
       <a href="google_interview_questions.html">140 Questions by Google</a> 
       <br><br>
       <br><br>
   <a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5 EXPRESS...</a>
   <br><br>
   <a href="../Win32API/Win32API_DLL.html">Win32 DLL ...</a>
   <br><br>
   <a href="cppNews.html">Articles On C++</a> 
   <br><br>
   <a href="C11/C11_initializer_list.html">What's new in C++11...</a> 
   <br><br>
   <a href="C11/1_C11_creating_thread.html">C++11 Threads EXPRESS...</a> 
   <br><br>
   <a href="../OpenCV/opencv_3_tutorial_imgproc_gausian_median_blur_bilateral_filter_image_smoothing.html">OpenCV...</a> 


<br />



  		
  	    </div>
          </div>
        </div>
      </div> <!-- / section -->
    </div>
  </div>

  <br>
<br>
<br>
<br>

<div class="custom-disqus">
<!-- Disqus -->
<!-- Disqus disabled Oct 17, 2016 
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
     
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
---- Disable -->
<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br>


<!-- footer starts here -->
<footer id="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-4 widget">
        <h3 class="widget-title">Contact</h3>
        <div class="widget-body">
          <p>BogoToBogo<br>
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
          </p>  
        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title">Follow Bogotobogo</h3>
        <div class="widget-body">

          <!--
          <ul>
            <li><a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a></li>
            <li><a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a></li>
            <li><a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a></li>
          </ul>
          -->
             <h3>
             <a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a> 
             <a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a> 
             <a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a> 
             </h3>

        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title"><a href="../about_us.html">About Us</a></h3>
        <div class="widget-body">
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
            <br>
            Golden Gate Ave, San Francisco, CA 94115
          </p>  
        </div>
      </div>

    </div> 
  </div>
</footer>

<footer id="underfooter">
  <div class="container">
    <div class="row">
      
      <div class="col-md-6 widget">
        <div class="widget-body">
          <p>Golden Gate Ave, San Francisco, CA 94115 </p>
        </div>
      </div>

      <div class="col-md-6 widget">
        <div class="widget-body">
          <p class="text-right">
            Copyright &copy; 2016, bogotobogo<br> 
            Design: <a href="../index.html" rel="designer">Web Master</a> </p>
        </div>
      </div>

    </div>
  </div>
</footer>

  <!-- JavaScript libs are placed at the end of the document so the pages load faster -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script type="text/javascript"
     src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- D3.js -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<!-- Google Analytics -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-12016988-2']);
    _gaq.push(['_trackPageview']);
    
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

<!-- Google Analytics --> 
<!-- We need this for Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43017326-1', 'bogotobogo.com');
  ga('send', 'pageview');

</script>
  
<!-- Google+ -->
<script type="text/javascript" src="http://apis.google.com/js/plusone.js"></script>

</body>

<!-- Mirrored from www.bogotobogo.com/cplusplus/multithreaded4_cplusplus11.php by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 10 Dec 2017 17:27:01 GMT -->
</html>

