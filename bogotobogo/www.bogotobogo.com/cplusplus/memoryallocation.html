<!DOCTYPE html>

<!-- Mirrored from www.bogotobogo.com/cplusplus/memoryallocation.php by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 11 Dec 2017 14:59:44 GMT -->
<head>
  <title>C++ Tutorial: Memory Allocation - 2017</title>
  <meta content="C++ Tutorial: Memory Allocation" name="description" />
  <meta content="C++ Tutorial, Memory Allocation, New Operator, Operator New, Delete, New, Delete [], malloc(), calloc(), realloc(), allocator class, placement new, memory leak, swap space, page fault" name="keywords" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.no-icons.min.css" rel="stylesheet">
  <link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Alice|Open+Sans:400,300,700">
  <link rel="stylesheet" href="../public/css/app.css">
  <link rel="stylesheet" href="../public/css/styles.css">
  <link rel="stylesheet" href="../public/css/bogostyleWidePreNew.css">
</head>

<body class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
    <div class="container-fluid">      
      <div class="navbar-header">
        <!--<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> -->
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse" aria-expanded="false" aria-controls="navbar"> 
          <span class="sr-only">Toggle navigation</span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
          <span class="icon-bar"></span> 
        </button>
        <a class="navbar-brand" href="../index-2.html">BogoToBogo</a>
      </div>
      
      <div class="navbar-collapse collapse">
        
        <ul class="nav navbar-nav">
          <li class="active"><a href="../index-2.html">Home</a></li>
          <li><a href="../about_us.html">About</a></li>
          <li><a href="../Hadoop/BigData_hadoop_Install_on_ubuntu_single_node_cluster.html">Big Data</a></li>
          <li><a href="../python/scikit-learn/Artificial-Neural-Network-ANN-1-Introduction.html">Machine Learning</a></li>
          <li><a href="../AngularJS/AngularJS_Introduction.html">AngularJS</a></li> 
          <li><a href="../python/pytut.html">Python</a></li>
          <li><a href="cpptut.html">C++</a></li>
          <li><a href="../DevOps/DevOps_Jenkins_Chef_Puppet_Graphite_Logstash.html">DevOps </a></li>
          <li><a href="../Algorithms/algorithms.html">Algorithms</a></li> 
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">More...<b class="caret"></b></a>
            <ul class="dropdown-menu">
           
              <li><a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5</a></li>                           
              <li><a href="../Android/android.html">Android</a></li>
              
              <li><a href="../Linux/linux_tips1.html">Linux</a></li>
              <li><a href="../Java/tutorials/on_java.html">Java</a></li>
              <li><a href="../CSharp/.netframework.html">CSharp</a></li>
              <li><a href="../VideoStreaming/videostreaming_etc.html">Video Streaming</a></li>
              <li><a href="../FFMpeg/ffmpeg_fade_in_fade_out_transitions_effects_filters_slideshow_concat.html">FFmpeg</a></li>
              <li><a href="../Matlab/Matlab_Tutorial_Manipulating_Audio_I_Reverse_Delay_Tone_Control_Changing_Speed_Removing_Vocals.html">Matlab</a></li>
              <li><a href="../python/Django/Python_Django_Forums_Shared_Host.html">Django 1.8</a></li>
              <li><a href="../Laravel5/Laravel5_ToDo_List_Sample.html">Laravel 5.2</a></li>
              <li><a href="../RubyOnRails/RubyOnRails.html">Ruby On Rails</a></li>
              <li><a href="../HTML5/HTML5_Tutorial.html">HTML5 & CSS</a></li>
              <li><a href="../AmazingPlaces/index.html" target="_blank">
<img src="../Menus/MenuIcons/Earth_8px_transparent_background.png"
width="24" height="24"/>Earth</a> </li>
            </ul>
          </li>
        </ul>      
      </div>
    </div>  
  </nav>  

  <div id="main">
    <div class="container">
      <div class="row section featured topspace">
        <div class="row">
          <div class="col-sm-9 col-md-9 col-xs-9">
            <h2 class="section-title">C++ Tutorial - Memory Allocation - 2017        <g:plusone></g:plusone></h2>
            <div class="icon-image">
                 <img src="images/cplusplus_icon.png" alt="cplusplus_icon.png"/>
            </div>
            <div class="SocialLinks">
  <span class='st__large' displayText=''></span>
  <br><br>
  <div align="center">
  <span class='st_facebook_large' displayText='Facebook'></span>
  <span class='st_twitter_large' displayText='Tweet'></span>
  <span class='st_linkedin_large' displayText='LinkedIn'></span>
  </div>
  <br><br>
  <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
  <script type="text/javascript">stLight.options({publisher: "b9569c43-5f56-4501-92f0-4bf4aa8fceb0", doNotHash: false, doNotCopy: true, hashAddressBar: false});</script>
</div>

<div id="bookmarkshare">
  <script type="text/javascript">var addthis_config = {"data_track_clickback":true};</script>
  <a class="addthis_button" href="http://www.addthis.com/bookmark.php?v=250&amp;username=khhong7"><img src="http://s7.addthis.com/static/btn/v2/lg-share-en.gif" width="125" height="16" alt="Bookmark and Share" style="border:0"/></a>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#username=khhong7"></script>
</div>

<br>
<hr>
<br>


<!-- Google bogo1 ad -->
<!-- Google search box -->



<!-- bogo1 -->
<div>
  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo1 -->
  <ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4716428189734495"
     data-ad-slot="6542308167"></ins>
  <script>
   (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>


<!-- Google search box -->
<div class="AdSenseSearch">
  bogotobogo.com site search:
  <form action="http://www.google.com/" id="cse-search-box" target="_blank">
    <div>
      <input type="hidden" name="cx" value="partner-pub-4716428189734495:1794050961" />
      <input type="hidden" name="ie" value="UTF-8" />
      <!--<input type="text" name="q" size="55" />-->
      <input type="text" name="q" size="" width="90%"/>
      <input type="submit" name="sa" value="Search" />
    </div>
  </form>
  <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en"></script>
</div>




<hr>
            <br><br><br>
<div class="subtitle" id="variables_memory">Variables and Memory</div>
<p>Variables represent storage space in the computer's memory. Each variable presents a
convenient names like <strong>number</strong> or <strong>result</strong> in the source code. Behind the scenes at runtime,
each variable uses an area of the computer's memory to store its value. </p>

<!-- Google bogo_square_ad -->
<div>
  <script type="text/javascript">
    google_ad_client = "ca-pub-4716428189734495";
    /* bogo_LargeRectangle_336_280 */
    google_ad_slot = "2712696561";
    google_ad_width = 336;
    google_ad_height = 280;
  </script>
  <script type="text/javascript"
    src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
  </script>
</div>
<br>





<p>However, not every variable in a program has a permanently assigned area of memory, instead,
modern languages are smart about giving memory to a variable only when necessary. When we use the term <strong>allocate</strong>, 
we indicate that the variable is given an area of memory to store its
value. A variable is <strong>deallocated</strong> when the system reclaims the memory from the
variable, so it no longer has an area to store its value. </p>
<p>For a variable, the period of time
from its allocation until its deallocation is called its <strong>lifetime</strong>.
The most common memory related error is using a deallocated variable. For <strong>local variables</strong>, modern languages automatically protect against this error. 
In other words, most of the time, the local variables 
appear automatically when we need them, and they disappear automatically when we
are done with them.
With <strong>pointers</strong>, however, programmers must make sure that allocation is handled correctly.</p>
<br/><br/>
<div class="subtitle_2nd" id="local_variables_memory">Local (or Automatic) Variables</div>
<p>The most common variables we use are <strong>local</strong> variables within functions such as the
variables <strong>number</strong> and <strong>result</strong> in the following function. All of the local variables and
parameters taken together are called its <strong>local storage</strong> or just its <strong>locals</strong>:</p>
<pre>
// Local storage example
int Square(int number) {
     int result;
     result = number * number;
     return result;
}
</pre>
<p>The variables are called <strong>local</strong> to represent the idea that their <strong>lifetime</strong> is tied to the
function where they are declared. Whenever the function runs, its local variables are
<strong>allocated</strong>. When the function exits, its locals are <strong>deallocated</strong>. </p>
<p>For the above example, that
means that when the <strong>Square()</strong> function is called, local storage is allocated for <strong>number</strong> and
<strong>result</strong>. When the function finally exits, its local storage is <strong>deallocated</strong>.</p>
<p>Locals 101:</p>
<ol>
<li> When a function is called, memory is allocated for all of its locals. In other
words, when the flow of control hits the starting <strong>{</strong> for the function, all of
its locals are allocated memory. Parameters such as <strong>number</strong> and local
variables such as <strong>result</strong> in the above example both count as <strong>locals</strong>. The
only difference between parameters and local variables is that <strong>parameters</strong>
start out with a value copied from the caller while <strong>local variables</strong> start with
random initial values.</li>
<br/>
<li> The memory for the locals continues to be allocated so long as the thread
of control is within the owning function. Locals continue to exist even if
the function temporarily passes off the thread of control by calling another
function. The locals exist undisturbed through all of this.</li>
<br/>
<li>Finally, when the function finishes and exits, its locals are deallocated.
This makes sense in a way (suppose the locals were somehow to
continue to exist) how could the code even refer to them? The names
like <strong>number</strong> or <strong>result</strong> only make sense within the body of <strong>Square()</strong>
anyway. Once the flow of control leaves that body, there is no way to refer
to the locals even if they were allocated. That locals are available
(<strong>scoped</strong>) only within their owning function.</li>
</ol>
<br/>
<br/>
<div class="subtitle_2nd" id="local_copies">Local Copies</div>
<p>Local parameters are basically local copies of the
information from the caller. This is also known as <strong>pass by value</strong>.</p>
<p><strong>Parameters</strong> are local variables which are initialized with an assignment (=)
operation from the caller. The caller is not <strong>sharing</strong> the parameter value
with the callee. In other words, the callee is getting its own copy.</p>
<p>This has the advantage that the callee can change its local copy without
affecting the caller. This independence is good since it keeps the operation of the
caller and callee functions separate which follows the rules of good
software engineering (keep separate components as independent as
possible).</p>
<p> However, since locals are copies of the caller
parameters, they do not provide a means of communication from the callee
back to the caller. This is the downside of the <strong>independence</strong> advantage.
Also, sometimes making copies of a value is very expensive.</p>
<br/><br/>
<div class="subtitle_2nd" id="local_bugs">A common bug: a function returning a pointer to a local variable  </div>
<p>The following code has the most common bug in it:</p>
<pre>
int* local_pointer() 
{
	int temp = 100;
	// returns a pointer to the local int
	return(<font color="red">&amp;</font>temp); 
}

int main()
{
	int* ptr = local_pointer();
	return 0;
}
</pre>
<p><strong>local_pointer()</strong> is actually fine while it is running. The problem happens to its caller after <strong>local_pointer()</strong> 
exits. <strong>local_pointer()</strong> returns a <strong>pointer</strong> to an <strong>int</strong>, but where is that <strong>int</strong> allocated? </p>
<p>The problem is that the <strong>local</strong> int, <strong>temp</strong>, is allocated only while <strong>local_pointer()</strong> is running. When <strong>local_pointer()</strong> exits,
all of its locals are deallocated. So the caller is left with a pointer to a deallocated
variable. <strong>local_pointer()</strong>'s locals are deallocated when it exits.</p>
<p>It is incorrect for <strong>local_pointer()</strong> to return a pointer to memory which is about to be
deallocated. We are essentially running into the <strong>lifetime</strong> constraint of local variables.
We want the int to exist, but it gets deallocated automatically. Not all uses of &amp; between
functions are incorrect - only when used to <strong>pass a pointer back to the caller</strong>.</p>
<p>When we actually run the small code, it appears to be OK. But the bug is still lurking there. We may see immediate effect when the code gets more complicated. In other words, in case when the system reclaim the memory area of the pointer:</p>
<pre>
int* local_pointer() 
{
	int temp = 100;
	// returns a pointer to the local int
	return(&amp;temp;); 
}

void f() { int array[10000] = {1};}

int main()
{
	int* ptr = local_pointer();
	<font color="red">f();</font>
	return 0;
}
</pre>
<p>Note that this bug happens when an <strong>&amp;</strong> passes a pointer to local storage 
from the called back to its caller. When the called exits, its local
memory is deallocated and so the pointer no longer has a pointee.</p>
<p>However, if we use <strong>&amp;</strong> to pass a pointer from the caller to the called, it's fine. 
The pointer remains valid for the callee to use because the caller locals continue to exist while the called is running.
The object that the pointer is pointing to will remain valid due to the simple constraint that the caller can only exit
sometime after its called function exits. Using <strong>&amp;</strong> to pass a pointer to local storage from the caller
to the called is fine. The reverse case, from the callee to the caller, is when the bug occurs as shown in the example above.</p>
<br/>
<br/>
<br/>
<br/>
<div class="subtitle" id="automaticmemory">Automatic Memory Management</div>
<p>Before we go into manual memory management, it might be better look at <strong>automatic</strong> memory management.</p>
<p>Automatic memory management is closely related to local variables. A local variable occupies memory that the system allocates when it sees the variable's definition during execution. The system also deallocates that memory automatically at the end of the block that contains the definition.</p>
<p>Programmers sometimes make a mistake of returning invalid pointer as we see in the example below. A pointer becomes invalid once the corresponding variable has been deallocated. </p>
<pre>
int * badPointer() {
	int i = 100;
	return &amp;i;
}
</pre>
<p>
The function badPointer() returns the address of the local variable i. However, when the function returns, actually ends the execution of the block and deallocates <strong>i</strong>. So, the pointer that <strong>&amp;i;</strong> is now no longer valid. Actually, the content of the variable <strong>i</strong> is correct at the moment the function returns. The problem is that the memory for  <strong>i</strong> is allocated in the stack frame for <strong>badPointer()</strong>. When <strong>badPointer()</strong> returns, all the memory in its stack frame is deallocated and made available for use by other functions. Still, the function tries to return it anyway. What's going to happen? Only the compiler knows.</p>
<p>If we insist on returning the &amp;i;, we can use <strong>static</strong>:</p>
<pre>
int * pointerToStatic() {
	<font color="red">static i;</font>
	return &amp;i;
}
</pre>
<p>This says that i is static and thus we allocate it once and we do not want to deallocate it as long as the code is running.</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="memoryFAQ">Memory, Cache, Registers</div>
<p>In general, computers have three locations for storing data - physical memory, cache, and registers. <strong>Memory</strong> is usually large compared with the other two types of storage. Each memory cell is accessed using an address, and the memory does not have to be consecutive. On various architectures, certain parts of the memory are used to access devices (this is called memory-mapped I/O). other parts of memory might not even be mapped into any physical memory at all.</p>
<p><strong>Cache</strong> is a smaller version of memory, stored either directly in the CPU (<strong>level 1</strong> cache), or on the motherboard (<strong>level 2</strong> cache). It stores a copy of <strong>recently used</strong> parts of the main memory, in a location that can be accessed much faster. Usually, because the cache is hidden from our our programs by the hardware, we do not need only worry about the cache unless we're dealing with kernel.</p>
<p>Registers are storage units inside the CPU with very fast access. They can be accessed much faster than memory, and are often used to store data that is needed for a short calculation, such as contents of local variables in a function, or intermediate results of arithmetic calculations. the keyword <strong>register</strong>, when used when defining a local variable, can be a hint to the compiler to assign that variable to a register, rather than to a memory cell. Since modern compilers are well optimized, it  might be better to let the compiler decide which variables should be kept in registers.</p>
<br/>
<br/>
<div class="subtitle" id="manualmemory">Manual Memory Management</div>
<p>When we talk about memory management, it's about deallocation since proper deallocation is crucial to the memory management.</p>
<p>To <strong>allocate</strong> a new object from the free store, C uses the <strong>malloc</strong> function and  C++ uses the <strong>new</strong> operator. The determination of when an object ought to be created is trivial and is not problematic. The critical issue, however, is the determination of when an object is no longer needed and arranging for its underlying storage to be returned to the <a href="assembly.html#heap_memory" target="_blank">free store (heap)</a> so that it may be re-used to satisfy future memory requests. In manual memory allocation, this is also specified manually by the programmer; via functions such as <strong>free()</strong> in C, or the <strong>delete</strong> operator in C++.</p>
<p>For more info on memory, please visit <a href="assembly.html#heap_memory" target="_blank">Taste of Assembly - heap memory<a></a> and <a href="assembly.html#stacks" target="_blank">Taste of Assembly - stack memory</a>.</a></p>
<br/>
<br/>
<div class="subtitle" id="memorybug">Sources of Memory Problems</div>
<p>The memory handling in C/C++ gives us a control as well as performance, but it comes with dangers.</p>
<ol>
<li><p><strong>Memory Leaks</strong><br/>
Memory leaks occur when data that are allocated at runtime but not deallocated once they are no longer needed. A program
which forgets to deallocate a block is said to have a <strong>memory leak</strong> which may or may
not be a serious problem. The result will be that the heap gradually fill up as there
continue to be allocation requests, but no deallocation requests to return blocks for reuse.<br/>
For a program which runs, computes something, and exits immediately, memory leaks
are not usually a concern. Such a <strong>one shot</strong> program could omit all of its deallocation
requests and still mostly work. Memory leaks are more of a problem for a program which
runs for an indeterminate amount of time. In that case, the memory leaks can gradually
fill the heap until allocation requests cannot be satisfied, and the program stops working
or crashes.<br/>
 Many commercial programs have memory leaks, so that when run for long
enough, or with large data-sets, it will consume memory resource, and eventually it will slow down our machine because of <a href="memoryallocation.html#swap_space" target="_blank">page swapping</a>. Then, we get failure with an <strong>out-of-memory</strong> error. <br/>
Finding those leaks with normal debugger is very tough because there is no clear faulty line of code. <br/>
Often the error detection and avoidance code for the heap-full error condition is not well tested, precisely because
the case is rarely encountered with short runs of the program - that's why filling the
heap often results in a real crash instead of a polite error message. <br/>
Most compilers have a <strong>heap debugging</strong> utility which adds debugging code to a program to track every
allocation and deallocation. When an allocation has no matching deallocation, that's a
leak, and the heap debugger can help us find them. 
</p></li>
<li><p><strong>Buffer Overruns</strong><br/>
Buffer overruns occur when memory outside of the allocated boundaries is overwritten. We call it data corruption. This is nasty because it may not become visible at the place where the memory is overwritten. It may appear when we access that memory address, which can happen much later part of code. When it happens, our program behaves strangely because the memory location has wrong value.</p></li>
<li><p><strong>Uninitialized Memory</strong><br/>
Since C/C++ allows us to create variables without an initial value, we may try to read data not initialized. The memory allocation function <strong>malloc()</strong> and <strong>operator new</strong> do not the allocated memory.</p></li>
<li><p><strong>Incorrect Memory Management</strong><br/>
This can occur when we call <strong>free()</strong> more than once, access memory after freeing it,<br/>
 or free a memory block that was never allocated as shown in the code below:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void populate(char **str) {
	// 1. OK
	*str = (char *)malloc(sizeof(char) * 7);
	strcpy(*str, "Memory");

	// 2. Not OK if later freeing the memory
	*str = "Memory";
}

int main() {
	char *s;
	populate(&amp;s;);
	printf("%s", s);   // should print "Memory"
	<font color="red">free</font>(s);
	return 0;
}

</pre>
This can also happen when we use <strong>delete</strong> instead of <strong>delete[]</strong>, or when we do memory management with wrong combination of memory functions: <strong>malloc()</strong> with <strong>delete</strong> or <strong>new</strong> with <strong>free()</strong>.</p></li>
</ol>
<br/>
<br/>
<div class="subtitle" id="newoperator">New Operator and Operator New</div>
<p>What's the difference between the <strong>new</strong> operator and <strong>operator new</strong>?</p>
<p>Let's look at the following line of code,:
<pre>
	string *pStr = <font color="red">new</font> string("Where is my place in Memory?");
</pre>
<p>the <strong>new</strong> is the <strong>new</strong> operator. Since this operator is built into C++, we can't change the behavior of the operator. What it does is twofold.</p>
<ol>
<li>It allocates enough memory to hold an object of the type requested. In the above example, it allocates enough memory to hold a <strong>string</strong> object.</li>
<li>It calls a <strong>constructor</strong> to <strong>initialize</strong> an object in the memory that was allocated.</li>
</ol>
<p>In C++, memory allocation and object construction are closely intertwined. When we use a <strong>new</strong>, memory is allocated, and an object is constructed in that memory. In other words, the <strong>new</strong> operator always does those two things and we can't change its meaning at all.</p>
<p>When we take over memory allocation, we must deal with those two tasks (allocation and construction). What we can change is <strong>how</strong> the memory for an object is allocated. The <strong>new</strong> operator calls a function to perform the required memory allocation, and we can <strong>rewrite</strong> or <strong>overload</strong> the function to change what it's doing. (More effective C++, Item #8 Understand the different meanings of <strong>new</strong> and <strong>delete</strong>, Scott Meyers)</p>
<p>So, what function is the <strong>new</strong> calling?<br/>
It is <strong>operator new</strong>.</p>
<pre>
	void * <font color="red">operator new</font> (size_t size);
</pre>
<p>The return type is <strong>void*</strong>. Since this function returns a pointer to <strong>raw</strong> which is <strong>not typed</strong> and <strong>uninitialized</strong> memory large enough to hold an object of the specified type. The <strong>size_t</strong> specifies how much memory to allocate.</p>
<p>It's rare but there is a chance we may want to call <strong>operator new</strong> directly.</p>
<pre>
	<font color="red">void *</font>pRawMemory = operator new(sizeof(string));
</pre>
<p>The <strong>operator new</strong> returns a pointer to a chunk of memory enough to hole a <strong>string</strong> object. <br/>
The <strong>operator new</strong> is similar to <strong>malloc</strong> in that it's responsible only for allocating memory. It knows nothing about constructors. All <strong>operator new</strong> understands is memory allocation. That's it. </p>
<p>It is the job of the <strong>new</strong> operator to take the <strong>raw</strong> memory that the <strong>operator new</strong> returns and make it into an object.</p>
<p>Let's look at the process of memory allocation and initialization from the perspective of compiler. When a compiler sees the following line,</p>
<pre>
	string *pStr = new string("Where is my place in Memory?");
</pre>
<p>the compiler generate a code something like this:</p>
<pre>
	void *pRawMemory = operator new(sizeof(string));
</pre>
<p>It obtains raw memory for a string object.</p>
<pre>
	call string::string("Where is my place in Memory?") 
	on *pRawMemory;
</pre>
<p>It then initialize the object in the memory by calling a constructor.</p>
<pre>
	string *pString = static_cast&lt;string*&gt;(memory);
</pre>
<p>The line of code above makes <strong>pString</strong> point to the new object.</p>
<p>When we use a <strong>delete</strong> expression to delete a dynamically allocated object:</p>
<pre>
delete ptr;
</pre>
<p>two things happen. First, the appropriate destructor is run on the object to which <strong>ptr</strong> points. Then, the memory used by the object is freed by calling a <strong>operator delete</strong> function.</p>
<p>Unlike other <strong>operator</strong> functions, such as <strong>operator=</strong>, the <strong>operator new</strong> and <strong>operator delete</strong> functions do not overload the <strong>new</strong> or <strong>delete</strong>. </p>
<br/>
<br/>
<div class="subtitle_2nd" id="operatornewinterface">Overloaded versions of operator new and operator delete</div>
<p>Note that <strong>operator new</strong> and <strong>operator delete</strong> apply only to allocations for single objects. Memory for array is allocated by <strong>operator new[]</strong> and deallocated by <strong>operator delete[]</strong>. Also note that heap memory for STL containers is managed by the containers' allocator objects, not by <strong>new</strong> and <strong>delete</strong> directly.</p>
<p>There are two overloaded versions of <strong>operator new</strong> and <strong>operator delete</strong> functions:</p>
<pre>
void *operator new(size_t);	// allocate an object
void *perator new[](size_t);  	// allocate an array

void *operator delete(void*);	// free an object
void *perator delete[](void*); 	// free an array
</pre>
<br/>
<br/>
<div class="subtitle" id="newoperator">New and Delete</div>
<p>When we use a <strong>new</strong> to create an object dynamically, two things happen as we discussed in the previous section: First, memory is allocated by calling <string>operator new. Second, one or more <strong>constructors</strong> are called for that memory. </string></p>
<p>Similar things happened when we use <strong>delete</strong>. one or more <strong>destructors</strong> are called for the memory, and then the memory is deallocated using <strong>operator delete</strong>.</p>
<p>The question for <strong>delete</strong> is <strong>how many</strong> objects reside in the memory being deleted? The answer to that question determines how many <strong>destructors</strong> should be called.</p>
<p>So, we should match the <strong>new</strong> and <strong>delete</strong>. Following example demonstrates what it means.</p>
<pre>
	string *pString = new string;
	string *pStringArray = new string[10];

	<font color="red">delete</font> pString;
	<font color="red">delete []</font> pStringArray;
</pre>
<p>In the case of array creation, the <strong>new</strong> operator behaves slightly differently from the case of single-object creation. Memory is no longer allocated by <strong>operator new</strong>. Instead, it's allocated by <strong>operator new[]</strong>.</p>
<p>Let's look at the process of creating and deleting array objects.</p>
<p>For arrays, a constructor must be called for <strong>each object</strong> in the array.</p>
<pre>
	string *pStringArray = new string[10];	
</pre>
<p>The code calls <strong>operator new[]</strong> to allocate memory for 10 string object, then call the default string constructor for each array element.</p>
<p>In the way, when the delete operator is used on an array, it calls a destructor for each array element and then calls <strong>operator delete[]</strong> to deallocate the memory. It calls the string destructor for each array element, then  calls <strong>operator delete[]</strong> to deallocate the array's memory.</p>
<pre>
	delete [] pstrStringArray;
</pre>
<p>We have two forms of <strong>delete</strong>:</p>
<ol>
<li><strong>delete ptr</strong> - frees the memory for an individual object allocated by <strong>new</strong>.</li>
<li><strong>delete ptr[]</strong> - frees the memory for an array of objects allocated by <strong>new</strong>.</li>
</ol>
<p>The following example has shows usage of <strong>delete</strong> and <strong>delete[]</strong>.
When we want delete the pointer to <strong>MyClass</strong>, we used <strong>delete</strong>, and in the destructor which is triggered by the <strong>delete myObj</strong> does delete array created on the heap.</p>
<br/>
<br/>
<img alt="memory_allocation_delete.png" src="images/memoryallocation/memory_allocation_delete.png"/>
<br/><br/>
<pre>
#include &lt;iostream&gt;
class MyClass 
{
public:
	MyClass() 
	{ 
		std::cout &lt;&lt; "default constructor" &lt;&lt; std::endl;
	}
	MyClass(int s):myArray(new double[s])
	{ 
		std::cout &lt;&lt; "constructor" &lt;&lt; std::endl; 
		for(int i = 0; i &lt; s; ++i) myArray[i] = 0;
	}
	~MyClass() 
	{  
                // this will be called @"delete myObj"
		std::cout &lt;&lt; "destructor" &lt;&lt; std::endl;
		<font color="red">delete[]</font> myArray;
	}
private:
	double *myArray;
};

int main(int argc, char** argv)
{
	MyClass *myObj = new MyClass(5);   //'5' here is the number of elements of array of double
	<font color="red">delete</font> myObj;  // this calls destructor
	return 0;
}
</pre>
<p>If we do not use the array version of delete, our program
may behave in odd ways. In some compilers, only the destructor for the 0th element of the array will be
called because the compiler only knows that you are deleting a pointer to an object. In others, memory
corruption may occur because new and new[] can use completely different memory allocation schemes.</p>
<p>
The destructors are only called if the elements of the array are plain objects, however, if we have an
array of pointers, we will still need to delete each element individually just as you allocated each element individually, as shown in the following code:</p>
<pre>
int main(int argc, char** argv)
{
	MyClass** myClassPtrArray = new MyClass*[5];

	// Allocate an object for each pointer.
	for (int i = 0; i &lt; 5; i++) 
		myClassPtrArray[i] = new MyClass();

	// Use myClassPtrArray.
	// Delete each allocated object.
	for (int i = 0; i &lt; 4; i++) 
		delete myClassPtrArray[i];

	// Delete the array itself.
	delete[] myClassPtrArray;
}
</pre>
<br/>
<br/>
<br/>
<div class="subtitle" id="initializing_memory">Initializing Dynamically Allocated Objects</div>
<pre>
	int i;                   // named but not initialized int variable
	int *pi = new int;       // pi is pointer to a dynamically allocated
		                 // unnamed and not initialized int

	int i(101);              // value of i is 101
	int *pi = new int(101);  // pi is pointing to an object whose value is 101

	string s(5, '1');                // value of s is "11111"
	string *ps = new string(5, '1'); // *ps is "11111"
	string *ps2 = new string()       // *ps is uninitialized empty string

	int *pi = new int        // pi points to an unitialized int
	int *pi = new int<font color="red">()</font>      // pi points to an integer initialized 0
</pre>
<p>The empty parenthesis is signaling that we want to initialization without supplying a specific initial value. Unlike the built-in types, in the case of class types that define their own constructors, the request for initialization does not have any consequence because the object will be initialized by the default constructor whether we leave it uninitialized of explicitly ask for initialization.</p>
<br/>
<br/>
<div class="subtitle" id="freestore">Free Store (C vs. C++)</div>
<p><strong>C</strong> does not provide the <strong>new</strong> and <strong>delete</strong> operators. To use <a href="assembly.html#memorydiagram">free store</a>, we should use functions dealing with memory. These functions are defined in the <strong>&lt;stdlib.h&gt;</strong>.</p>
<pre>
void* malloc(size_t sz)            /* allocate sz bytes */
void free(void *p)                 /* deallocate the memory pointed to by p */
void* calloc(size_t n, size_t sz); /* allocate n*sz bytes initialized to 0 */
void* realloc(void* p, size_t sz); /* reallocate the memory pointed to by p  
                                      tp a space of size sz */
</pre>
<p>The <strong>typedef sizt_t</strong> is an unsigned type.</p>
<p>Why does <strong>malloc()</strong> return a <strong>void*</strong>?<br/>
It's because <strong>malloc()</strong> has no idea which type of object we want to put in that memory. Initialization is our responsibility. For example:</p>
<pre>
#include &lt;stdlib.h&gt;

struct Student {
	const char *name;
	int id;
};

int main()
{
	struct Student s = {"Park", 12345};
	/* allocate */
	struct Student* ss = (struct Student*)malloc(sizeof(Student));
	/* initialize */
	ss-&gt;name = "Hong";
	ss-&gt;id = 67890;
	return 0;
}
</pre>
<p>Note that we can't write in either C or C++.</p>
<pre>
*ss = {"Lee", 43145};
</pre>
<p>But in C++, after we define a constructor, we can write:</p>
<pre>
Student *ss = new Student("Lee", 43145);
</pre>
<br/>
<br/>
<br/>
<div class="subtitle" id="memoryOnC">Memory Management in C - malloc(), calloc(), and realloc()</div>
<br/>
<ol>
<li>The C compiler lays out memory corresponding to functions(arguments, variables) on the <strong>stack</strong>.</li>
<li>C allows the programmer to allocate additional memory on the <strong>heap</strong>.</li>
</ol>
<br/>
<table border="1" cellpadding="5">
<tr>
<th> </th>
<th>Stack</th>
<th>Heap</th>
</tr>
<tr>
<td>memory is allocated</td>
<td>upon entering function</td>
<td>with <strong>malloc</strong></td>
</tr>
<tr>
<td>memory is deallocated</td>
<td>upon function return</td>
<td>with <strong>free</strong></td>
</tr>
<tr>
<td>addresses are assigned</td>
<td>statically</td>
<td>dynamically</td>
</tr>
</table>
<br/><br/>
<ol>
<li><strong>allocation</strong><br/>
<strong>malloc</strong> is a C standard library function that finds a chunk of free
memory of the desired size and returns a pointer to it.
<pre>
int *p = malloc(sizeof(int));
</pre>
</li>
<li><strong>deallocation</strong><br/>
<strong>free</strong> marks the memory associated with a specific address as no
longer in use. (It keeps track of how much memory was associated
with that address)
 </li>
<pre>
free(p);
</pre>

</ol>
<br/>
<p>Memory can be allocated dynamically with the <strong>malloc()</strong> function, and it can be released using <strong>free()</strong> when it's no longer needed.</p>
<p>The <strong>malloc()</strong> function requires an integer value for its argument to specify the bytes of memory, and it returns a pointer (void *).
to the allocated space. The <strong>free()</strong> takes a pointer to the space for its argument. Here is a simple example:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
	int max = 10;
	char *buffer;
	buffer = (char*)malloc( (max+1)* sizeof(char));
	if(buffer != NULL) {
		for(int i = 0; i &lt; max; i++) 
			buffer[i] = 'a'+ i;

		buffer[max] = '\0';

                  // This will print out "buffer=abcdefghij"
		printf("buffer=%s\n",buffer);   

		free (buffer);
		return 0;
	}
	else {
		printf("Not enough memory\n");
		return 1;
	}
}
</pre>
<p>If the <strong>malloc()</strong> cannot get the space requested, it returns a NULL. In the example, <strong>sizeof()</strong> is used to calculate the total amount of bytes to reserve because the number of bytes used to store vary from system to system.</p>
<p>There is another function which is very similar to the <strong>malloc()</strong>. It is <strong>calloc()</strong>.</p>
<ol>
<li>The <strong>calloc()</strong> takes two integer arguments. These are multiplied together to specify how much memory to allocate.</li>
<li>The <strong>calloc()</strong> initializes all the allocated memory space to zero whereas <strong>malloc()</strong> leaves whatever values may already be there.</li>
</ol>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{	
	int *ptrc = (int*)calloc(10, sizeof(int));
	int *ptrm = (int*)malloc(10);
	for (int i = 0; i &lt; 10; i++) 
		printf("%d calloc: %d malloc: %d\n",i,*ptrc++, *ptrm++); 
	return 0;
}
</pre>
<p>Output is;</p>
<pre>
0 calloc: 0 malloc: -842150451
1 calloc: 0 malloc: -842150451
2 calloc: 0 malloc: -33698355
3 calloc: 0 malloc: 65021
4 calloc: 0 malloc: 1241163875
5 calloc: 0 malloc: 201340432
6 calloc: 0 malloc: 1913376
7 calloc: 0 malloc: 0
8 calloc: 0 malloc: 267805232
9 calloc: 0 malloc: 91
</pre>
<p>Memory that has been allocated with <strong>malloc()</strong> or <strong>calloc()</strong> can be increased by using <strong>realloc()</strong>.</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{	
	int *ptrc = (int*)calloc(10, sizeof(int));
	int *ptrm = (int*)malloc(10);
	for (int i = 0; i &lt; 10; i++) 
		printf("%d calloc: %d malloc: %d\n",i,*(ptrc+i), *(ptrm+i)); 

	ptrc = (int*)realloc(ptrc, 20*sizeof(int));
	ptrm = (int*)realloc(ptrm, 20*sizeof(int));
	for (int i = 0; i &lt; 20; i++) 
		printf("%d calloc: %d malloc: %d\n",i,*ptrc++, *ptrm++); 
	return 0;
}
</pre>
<p><strong>realloc()</strong> changes the size of the object pointed to by <strong>ptrc/ptrm</strong> to <strong>10*sizeof(int)</strong>. The contents will be unchaged up to the minimum of the old and new sizes. If the new size is larger, the new space is uninitialized. <strong>realloc()</strong> returns a pointer to the new space, or NULL if the request cannot be satisfied, in which case <strong>ptrc/ptrm</strong> are unchanged.</p>
<p>Output is:</p>
<pre>
0 calloc: 0 malloc: -842150451
1 calloc: 0 malloc: -842150451
2 calloc: 0 malloc: -33698355
3 calloc: 0 malloc: 65021
4 calloc: 0 malloc: 1695717995
5 calloc: 0 malloc: 201345347
6 calloc: 0 malloc: 5845536
7 calloc: 0 malloc: 0
8 calloc: 0 malloc: 265708080
9 calloc: 0 malloc: 91
0 calloc: 0 malloc: -842150451
1 calloc: 0 malloc: -842150451
2 calloc: 0 malloc: -842150451
3 calloc: 0 malloc: -842150451
4 calloc: 0 malloc: -842150451
5 calloc: 0 malloc: -842150451
6 calloc: 0 malloc: -842150451
7 calloc: 0 malloc: -842150451
8 calloc: 0 malloc: -842150451
9 calloc: 0 malloc: -842150451
10 calloc: -842150451 malloc: -842150451
11 calloc: -842150451 malloc: -842150451
12 calloc: -842150451 malloc: -842150451
13 calloc: -842150451 malloc: -842150451
14 calloc: -842150451 malloc: -842150451
15 calloc: -842150451 malloc: -842150451
16 calloc: -842150451 malloc: -842150451
17 calloc: -842150451 malloc: -842150451
18 calloc: -842150451 malloc: -842150451
19 calloc: -842150451 malloc: -842150451
</pre>
<br/>
<br/>
<div class="subtitle" id="free_function">void free(void*)</div>
<p><strong>void free(void* heapBlockPointer)</strong>.<br/>
 The <strong>free()</strong> function
takes a pointer to a heap block and returns it to the free pool for later reuse.
The pointer passed to <strong>free()</strong> must be exactly the pointer returned
earlier by <strong>malloc()</strong>, not just a pointer to somewhere in the block.</p>
<p>Calling <strong>free()</strong> with the wrong sort of pointer is famous for the particularly ugly
sort of crashing which it causes. The call to <strong>free()</strong> does not need to give
the size of the heap block - the heap manager will have noted the size in
its private data structures. The call to <strong>free()</strong> just needs to identify which
block to deallocate by its pointer. If a program correctly deallocates all of
the memory it allocates, then every call to <strong>malloc()</strong> will later be matched
by exactly one call to <strong>free()</strong>.</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="malloc_vs_new">Malloc() vs new - Object Creation and construction</div>
<p>The main advantage of <strong>new</strong> over <strong>malloc()</strong> is that new doesn't just allocate memory, it <strong>constructs</strong> objects.</p>
<pre>
Foo* objMalloc = (Foo*)malloc(sizeof(Foo));
Foo* objNew = new Foo();
</pre>
<p>After a run, both <strong>objMalloc</strong> and <strong>objNew</strong> will point to areas of memory in the heap that
are big enough for a Foo object. Data members and methods of Foo can be accessed using both pointers.
The difference is that the Foo object pointed to by <strong>objMalloc</strong> isn't a proper object because it was never constructed. The malloc() function only sets aside a piece of memory of a certain size. It doesn't know about or care about objects. In contrast, the call to new will allocate the appropriate size of memory and
will also properly construct the object. </p>
<p>
A similar difference exists between the <strong>free()</strong> and the <strong>delete</strong> functions. With free(), the
object's destructor will not be called. With delete, the destructor will be called and the object will be
properly cleaned up.
</p>
<br/>
<br/>
<br/>
<div class="subtitle" id="placementnew">Placement new Operator</div>
<p>The function <strong>operator new</strong> allocates but does not initialize memory. The <strong>new</strong> operator has the responsibility of finding in the heap a block of memory that is large enough to hold the amount of memory we request. As a variation of the <strong>new</strong> operator, <strong>placement new</strong> allows us to specify the location to be used. In other words, it allows us to construct an object at a specific, preallocated memory address. The form of a <strong>placement new</strong> is:</p>
<pre>
new (place) type
new (place) type (initialization list)
</pre>
<p>where <strong>place</strong> must be a pointer and the <strong>initialization list</strong> provides list of initialization to use when constructing the newly allocated object.</p>
<p>To use the placement <strong>new</strong>, we should include the <strong>new</strong> header file, which provides a prototype for this version of <strong>new</strong>. Then, we use <strong>new</strong> with an argument that provides the intended address:</p>
<pre>
#include &lt;new&gt;

class A
{
	char c[100];
	int n;
};

char buf1[200];
char buf2[400];

int main()
{
	A *pA1, *pA2;
	int *pI1, *pI2;
	pA1 = new A();			// placing a class in heap
	pI1 = new int[10];		// placing an int array in heap

	pA2 = new (buf1) A;		// placing a class in buf1
	pI2 = new (buf2) int[10];	// placing an int array in buf2

	delete pA1;
	delete[] pI1;

	return 0;
}
</pre>
<p>The placement <strong>new</strong> simply uses the address that is passed to it. It doesn't keep track of whether that location has already been used, and it doesn't search the block for unused memory. This shifts the burden of memory management to the programmer.</p>
<p>For regular <strong>new</strong>, the statements</p>
<pre>
delete pA1;
delete[] pI1;
</pre>
<p>free up the block of memory. However, as we saw in the example, we did not use <strong>delete</strong> to free the memory used by placement <strong>new</strong>. Actually, it couldn't. The memory specified by <strong>buf</strong> is static memory, and <strong>delete</strong> can be used only for a pointer to heap memory allocated by normal <strong>new</strong>. </p>
<p>To see a problem of memory management of the previous example, here, a little bit modified version with a constructor using <strong>new</strong> to make a pointer to a char array and with a destructor which frees the memory occupied by the character array:</p>
<pre>
#include <iostream>
#include <new>
using namespace std;

class A
{
	char c[100];
	int n;
	char *str;

public:	
	A() 
        {
		str = <font color="red">new</font> char[10];
	}

	~A() 
        {
		cout &lt;&lt; "~A" &lt;&lt; endl;
		<font color="red">delete[]</font> str;
	}
};

char buf1[200];
char buf2[400];

int main()
{
	A *pA1, *pA2;
	int *pI1, *pI2;
	pA1 = new A();			// placing a class in heap
	pI1 = new int[10];		// placing an int array in heap

	pA2 = new (buf1) A;		// placing a class in buf1
	pI2 = new (buf2) int[10];	// placing an int array in buf2

	delete pA1;
	delete[] pI1;

	return 0;
}
</new></iostream></pre>
<p>Output is:</p>
<pre>
~A
</pre>
<p>Note that the destructor is called at:</p>
<pre>
delete pA1;
</pre>
<p>But we need to call another destructor for the object created by:</p>
<pre>
pA2 = new (buf1) A;
</pre>
<p>How can we do that?</p>
<p>Here is the solution: add the following line at the end of the main().</p>
<pre>
pA2-&gt;~A();
</pre>
<p>Then, the output becomes:</p>
<pre>
~A
~A
</pre>
<p>We call the destructor explicitly for any object created by placement <strong>new</strong>. Normally, destructors are called automatically, and this is one of the rare cases that require an explicit call. An explicit call to a destructor requires identifying the object to be destroyed. </p>
<br/>
<br/>
<br/>
<div class="subtitle" id="robustmemalloc">Common Bugs for Memory Allocation</div>
<p>Most C++ bugs arise from some kind of misuse of pointers and references:</p>
<ol>
<li><p><strong>Null dereferencing</strong><br/>
Trying to use -&gt; or * operator on a NULL pointer.</p></li>
<li><p><strong>Double Freeing</strong><br/>
Calling <strong>delete</strong> or <strong>free()</strong> on a block of memory twice.</p></li>
<li><p><strong>Accessing invalid memory</strong><br/>
Trying to use -&gt; or * operator on a pointer that has not been allocated yet or that has been freed already.</p></li>
<li><p><strong>Mixing allocators</strong><br/>
Using <strong>delete</strong> to free memory that was allocated with <strong>malloc()</strong> or using <strong>free()</strong> to return memory allocated with <strong>new</strong>.</p></li>
<li><p><strong>Incorrect array deallocation</strong><br/>
Using <strong>delete</strong> operator instead of <strong>delete[]</strong> to free an array.</p>
</li>
<li><p><strong>Memory leaks</strong><br/>
Not freeing a block of memory when we are finished with it.</p>
</li>
</ol>
<p>These problems arise because it's hard to to tell whether a C++ pointer is referencing valid memory or if it is pointing to unallocated or freed memory. But we can avoid these problems by using managed pointers (smart pointers). These pointers are not part of the original C++98 specification. But they were included in TR1 (Technical Report 1). They are also included in the C++0X. The <a href="boost.html">Boost</a> libraries provide</p> portable, open source implementaton of these pointers: <strong>boost::shared_ptr, boost::weak_ptr, boost::scoped_ptr</strong>.</p>
<ol>
<li><p><strong>Shared pointers</strong><br/>
Shared pointers are reference-counted pointers where the reference count incremented by one when a piece of code wants to hold onto the pointer and decremented by one when it is finished using the pointer. When the reference count is zero, the object pointed to by the pointer is automatically freed. So, the shared pointers can help avoid the problems of accessing freed memory by ensuring that the pointer remains valid for the period that we wish to use it.</p></li>
<li><p><strong>Weak pointers</strong><br/>
A weak pointers contains a pointer to an object, normally a shared pointer, but it does not contribute to the reference count for that object. If we have a shared pointer and a weak pointer referencing the same object, and the shared pointer is destroyed, the weak pointer immediately becomes NULL. So, weak pointers can detect whether the object being pointed to has expired if the reference count for the object it is pointing to is zero. This helps avoiding the dangling pointer problem where we can have a pointer that is referencing freed memory.</p></li>
<li><p><strong>Scoped pointers</strong><br/>
Scoped pointers support ownership of single objects and automatically deallocate their objects when the pointer goes out of scope. So, sometimes they are called auto pointers (compare this with  <a href="autoptr.html" target="_blank">auto_ptr</a>). Scope pointers are defined as owning a single object, so it cannot be copied.</p></li>
</ol>
<p>Let's look at the following example:</p>
<pre>
#include &lt;iostream&gt;
#include &lt;boost/smart_ptr/shared_ptr.hpp&gt;
typedef boost::shared_ptr&lt;class MyClass&gt; ptrInstance;

class MyClass
{
public:
	static ptrInstance createInstance();
	~MyClass(){std::cout &lt;&lt; "Dtor()" &lt;&lt; std::endl;};
private:
	MyClass() {std::cout &lt;&lt; "Ctor()" &lt;&lt; std::endl;};
};

ptrInstance MyClass::createInstance()
{
	return ptrInstance(new MyClass());
}

void makeMyClass() 
{
	ptrInstance ptr = MyClass::createInstance();
	ptr = MyClass::createInstance();
}

int main()
{
	makeMyClass();
	return 0;
}
</pre>
<p>In the example, two instances of <strong>MyClass</strong> are created, and both of these instances are destroyed when the <strong>ptr</strong> goes out of scope. If instead the <strong>createInstance()</strong> method simply return a <strong>MyClass *</strong> type, then the destructor would never get called in the example. The use of smart pointers can therefore make memory management simpler.</p>
<p>In general, if we have a function that returns a pointer that our clients should delete or if we expect the client to need the pointer for longer than the life of our object, then we should return it using a samrt pointer. However, if ownership of the pointer will be retained by our object, then we can return a standard pointer as below:</p>
<pre>
static MyClass* createInstance();
</pre>
<p>instead of </p>
<pre>
static boost::shared_ptr<class myclass> createInstance();
</class></pre>
<br/>
<p>Check also, <a href="CppCrashDebuggingMemoryLeak.html" target="_blank">Debugging Crash &amp; Memory Leak</a>.</p>
<br/>
<br/>
<div class="subtitle" id="swap_space">Swap Space &amp; Page Fault</div>
<p>In this section, we will talk about memory limited to Linux system though it may be applied to other systems as well.<br/>
The application's allocated memory is managed by the Linux kernel. Whenever the program asks for memory or tries to read from or write to memory that is has allocated, the Linux kernel takes charge and decides how to handle the request.</p>
<p>Initially, the kernel was simply able to use free physical memory to satisfy the application's request for memory, however, once physical memory was full, it started using <strong>swap space</strong>. This is a separate disk area allocated when the system was configured, and the Linux kernel does all the management for us. In other words, the part of the hard disk that is used as virtual memory is called the swap space.</p>
<p>The kernel moves data and program code between physical memory and the swap space so that each time we read/write memory, the data always appears to have been in physical memory, wherever it was actually located before we attempted to access it.</p>
<p>The area of the hard disk that stores the RAM image is called a <strong>pagefile</strong>. It holds pages of RAM on the hard disk, and the operating system moves data back and forth between the page file and RAM. On a Windows machine, page files have a .SWP extension.</p>
<p>Actually, Linux implements a demand paged <strong>virtual memory</strong> system. All memory seen by the user programs is <strong>virtual</strong>. In other words, it does not exist at the physical address the program uses. Linux divides all memory into pages, commonly, 4,096 bytes per page. When a program tries to access memory, a virtual-to-physical translation is made. When the access is to memory that is not physically resident, a <strong>page fault</strong> results and control is passed to the kernel.</p>
<p>Some of the virtual memory sections might be mapped to no physical memory page. So, when a process tries to access a memory cell in such a section, the CPU identifies a <strong>page fault</strong>, and invokes an OS routine that needs to handle this fault. Most OSs use this feature to store part of the virtual memory sections on disk, rather than in RAM, thereby allowing the program to use an address space larger than the physical RAM of the machine. When a page fault occurs, the OS loads the contents of the faulted virtual memory section from the disk, copies it into a free physical memory page, and updates the virtual memory translation table so the CPU will know to map the virtual memory section to the new physical RAM page.</p>
<p>In Linux, the kernel checks the address being accessed and, if it's a legal address for that program, determines which page of physical memory to make available. It then either allocates it, if it has never been written before, or, if it has been stored on the disk in the swap space, reads the memory page containing the data into physical memory, possibly moving an existing page out to disk. Then, after mapping the virtual memory address to match the physical address, it allows the user program to continue. Linux applications do not need to worry about this activity because the implementation is all hidden in the kernel.</p>
<p>However, if the application exhausts both the physical memory and the swap space, or when the maximum stack size is exceed, the kernel finally refuses the request for further memory and may preemptively terminate the program.</p>
<br/>
<br/>
<div class="subtitle" id="virtual_memory">Virtual Memory &amp; Memory Protection</div>
<p>The OS uses a translation table to map virtual memory to physical memory, and the system can use a different translation table for each process, thereby giving each process its own address space. <p>
<br/>
<img alt="Virtual_Address" src="images/memoryallocation/Virtual_Address.png"/>
<p>Picture from <a href="http://en.wikipedia.org/wiki/Address_space" target="_blank">http://en.wikipedia.org/wiki/Address_space</a></p>
<br/>
<p>This means that the same virtual memory address used by two different processes, will be mapped into two different physical memory addresses. In other words, one process cannot access the contents of the memory used by the other process, and thus one process corrupting its memory won't interfere with the contents of the memory of any other process in the system. This feature is known as <strong>memory protection</strong></p>
<br/>
<br/>
<br/>
<div class="subtitle" id="garbage_collection">How to implement garbage collection in C++</div>
<p>From <a href="http://stackoverflow.com/questions/5009869/how-to-implement-garbage-collection-in-c" target="_blank">How to implement garbage collection in C++</a>.</p>
<p>Garbage collection in C and C++ are both difficult topics for a few reasons:</p>
<ol>
<li>Pointers can be <strong>typecast</strong> to integers and vice-versa. This means that I could have a block of memory that is reachable only by taking an integer, typecasting it to a pointer, then dereferencing it. A garbage collector has to be careful not to think a block is unreachable when indeed it still can be reached.</li>
<li>Pointers are not opaque. Many garbage collectors, like stop-and-copy collectors, like to move blocks of memory around or compact them to save space. Since you can explicitly look at pointer values in C and C++, this can be difficult to implement correctly. You would have to be sure that if someone was doing something tricky with typecasting to integers that you correctly updated the integer if you moved a block of memory around.</li>
<li><strong>Memory management</strong> can be done explicitly. Any garbage collector will need to take into account that the user is able to explicitly free blocks of memory at any time.</li>
<li>In C++, there is a separation between <strong>allocation/deallocation</strong> and object <strong>construction/destruction</strong>. A block of memory can be allocated with sufficient space to hold an object without any object actually being constructed there. A good garbage collector would need to know, when it reclaims memory, whether or not to call the destructor for any objects that might be allocated there. This is especially true for the standard library containers, which often make use of std::allocator to use this trick for efficiency reasons.</li>
<li>Memory can be allocated from different areas. C and C++ can get memory either from the built-in freestore (malloc/free or new/delete), or from the OS via <strong>mmap</strong> or other system calls, and, in the case of C++, from get_temporary_buffer or return_temporary_buffer. The programs might also get memory from some third-party library. A good garbage collector needs to be able to track references to memory in these other pools and (possibly) would have to be responsible for cleaning them up.</li>
<li><strong>Pointers</strong> can point into the middle of objects or arrays. In many garbage-collected languages like Java, object references always point to the start of the object. In C and C++ pointers can point into the middle of arrays, and in C++ into the middle of objects (if multiple inheritance is used). This can greatly complicate the logic for detecting what's still reachable.</li>
</ol>
<p>
So, in short, it's <strong>extremely hard</strong> to build a garbage collector for C or C++. Most libraries that do garbage collection in C and C++ are extremely conservative in their approach and are technically unsound - they assume that you won't, for example, take a pointer, cast it to an integer, write it to disk, and then load it back in at some later time. They also assume that any value in memory that's the size of a pointer could possibly be a pointer, and so sometimes refuse to free unreachable memory because there's a nonzero chance that there's a pointer to it.</p>
<p>
As others have pointed out, the <strong>Boehm GC</strong> does do garbage collection for C and C++, but subject to the aforementioned restrictions.</p>
<p>
Interestingly, the upcoming <strong>C++0x</strong> standard will include some new library functions that allow the programmer to mark regions of memory as reachable and unreachable in anticipation of future garbage collection efforts. It may be possible in the future to build a really good C++ garbage collector with this sort of information. In the meantime though, you'll need to be extremely careful not to break any of the above rules.</p>
<br/>
<br/>
<img alt="SunChunMan2" src="images/memoryallocation/SunChunMan2.png"/>
<br/>
<br/>
</p></p>
<div>
    
<div class="custom-disqus">
<!-- Disqus -->
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
/* Disabling Disqus 4/26/2017
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
 Disabling Disqus */    
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br></div>
          </div>
          <div class="col-sm-3 col-md-3 col-xs-3">
  	    <div class="g-person" data-width="1" data-href="//plus.google.com/111664369941456137911" data-rel="author">
  	    </div>
            <div class="resume">
              <p>Ph.D. / Golden Gate Ave, San Francisco / Seoul National Univ / Carnegie Mellon / UC Berkeley / DevOps / Deep Learning / Visualization</p>
            </div>
  	    <div>
                
<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----MIIHRwYJKoZIhvcNAQcEoIIHODCCBzQCAQExggEwMIIBLAIBADCBlDCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb20CAQAwDQYJKoZIhvcNAQEBBQAEgYC0In+maN+zseQtRj6SJqP9kj2LLvKf0yFklTm01uHY7UwgB3YJ0MZwvi6iERXfh4x2/KVYyMzY6elATG68c3gd6gb0Pqca380dXCg2Xua8jlW0pTZ3UabUNkpYi0iIwMSUsvWKbIw9eX8cBljOrYU1CXNuk46c0Yz2J3lGG+xCZTELMAkGBSsOAwIaBQAwgcQGCSqGSIb3DQEHATAUBggqhkiG9w0DBwQI23eIgGIDbFqAgaDMolOA+os0Y06D0j9NgHZJahDCSSl3deolhu6gz8hNd0SKwNAMBDPd5LBjJ7v6QgReCprB9L2E6CVpXZwgyLnzPC/wHbQG0Qd9sc/CqbiFy2FaJodDtPbRS8mOh+aHph0pNXgZ2kRA8uqVGIRF5gc0d6wqx7+NrPK5FehCMWoGGTmfTTMlykPVQhwDAY8+QFNSbCnqih5GXX62XpkmMJWFoIIDhzCCA4MwggLsoAMCAQICAQAwDQYJKoZIhvcNAQEFBQAwgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMB4XDTA0MDIxMzEwMTMxNVoXDTM1MDIxMzEwMTMxNVowgY4xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEUMBIGA1UEChMLUGF5UGFsIEluYy4xEzARBgNVBAsUCmxpdmVfY2VydHMxETAPBgNVBAMUCGxpdmVfYXBpMRwwGgYJKoZIhvcNAQkBFg1yZUBwYXlwYWwuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDBR07d/ETMS1ycjtkpkvjXZe9k+6CieLuLsPumsJ7QC1odNz3sJiCbs2wC0nLE0uLGaEtXynIgRqIddYCHx88pb5HTXv4SZeuv0Rqq4+axW9PLAAATU8w04qqjaSXgbGLP3NmohqM6bV9kZZwZLR/klDaQGo1u9uDb9lr4Yn+rBQIDAQABo4HuMIHrMB0GA1UdDgQWBBSWn3y7xm8XvVk/UtcKG+wQ1mSUazCBuwYDVR0jBIGzMIGwgBSWn3y7xm8XvVk/UtcKG+wQ1mSUa6GBlKSBkTCBjjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1Nb3VudGFpbiBWaWV3MRQwEgYDVQQKEwtQYXlQYWwgSW5jLjETMBEGA1UECxQKbGl2ZV9jZXJ0czERMA8GA1UEAxQIbGl2ZV9hcGkxHDAaBgkqhkiG9w0BCQEWDXJlQHBheXBhbC5jb22CAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQUFAAOBgQCBXzpWmoBa5e9fo6ujionW1hUhPkOBakTr3YCDjbYfvJEiv/2P+IobhOGJr85+XHhN0v4gUkEDI8r2/rNk1m0GA8HKddvTjyGw/XqXa+LSTlDYkqI8OwR8GEYj4efEtcRpRYBxV8KxAW93YDWzFGvruKnnLbDAF6VR5w/cCMn5hzGCAZowggGWAgEBMIGUMIGOMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDU1vdW50YWluIFZpZXcxFDASBgNVBAoTC1BheVBhbCBJbmMuMRMwEQYDVQQLFApsaXZlX2NlcnRzMREwDwYDVQQDFAhsaXZlX2FwaTEcMBoGCSqGSIb3DQEJARYNcmVAcGF5cGFsLmNvbQIBADAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTUwOTA2MTYwNDAxWjAjBgkqhkiG9w0BCQQxFgQUuyx70nay4O6eJQs3x4WiAm4/7DkwDQYJKoZIhvcNAQEBBQAEgYAN7yS/34G8dBK6CfFf5g4rQk/H8s7D/aUmIzppGWOoXR7nZuXQo99wSBlQsPdeFtB+a+NNapf6lC4ibUTjgSpbu1gscGHH4Y+QtXl03bt5qgaSoFhZsCJKubwRHPHGHDGVx+tQmQ2DHk09lXjjL61FpB6iqkiFFvw4vfixsoeI6g==-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>




<!-- Place this tag after the last widget tag. -->
<script type="text/javascript">
        (function() {
          var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
          po.src = 'https://apis.google.com/js/platform.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
</script>
  	    </div>
  	    <div class="side_menu">
                <br /><br />

<div class="skyscraper">
  <br>


<div class="skyscraper">

  <div class="bogo-paypal">
    <!-- Paypal Donate button -->
    <p><i>Sponsor Open Source development activities and free contents for everyone.</i></p>

    <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
    <input type="hidden" name="cmd" value="_s-xclick">
    <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
    ">
    <input type="image" src="https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_pp_142x27.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
    <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
    </form>
    <p><i>Thank you.</i></p>
    <p>- <a href="../about_us.html" target="_blank">K Hong</a></p>
    <!-- End of Paypal Donate button   -->
  </div>


  <script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- bogo_skyscraper -->
  <ins class="adsbygoogle"
       style="display:inline-block;width:160px;height:600px"
       data-ad-client="ca-pub-4716428189734495"
       data-ad-slot="5321096966"></ins>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  <br><br>





</div></div>

<!-- cplusplus_list_INNER.php -->
<br><br><br>
<h1>C++ Tutorials</h1>
   <a href="cpptut.html">C++ Home</a> 
   <br><br>
   <a href="../Algorithms/algorithms.html">Algorithms & Data Structures in C++ ...</a>
   <br><br>
   <a href="application_visual_studio_2013.html">Application (UI) - using Windows Forms (Visual Studio 2013/2012)</a>
   <br><br>
   <a href="autoptr.html">auto_ptr</a>
   <br><br>
   <a href="binarytree.html">Binary Tree Example Code</a>
   <br><br>
   <a href="blackjackQT.html">Blackjack with Qt</a>
   <br><br>
   <a href="boost.html">Boost - shared_ptr, weak_ptr, mpl, lambda, etc.</a>
   <br><br>
   <a href="Boost/boost_AsynchIO_asio_tcpip_socket_server_client_timer_A.html">Boost.Asio (Socket Programming - Asynchronous TCP/IP)...</a>
   <br><br>
   <a href="class.html">Classes and Structs</a> 
   <br><br>
   <a href="constructor.html">Constructor</a> 
   <br><br>
   <a href="cplusplus11.html">C++11(C++0x): rvalue references, move constructor, and lambda, etc.</a> 
   <br><br>
   <a href="cpptesting.html">C++ API Testing</a>
   <br><br>
   <a href="cplusplus_keywords.html">C++ Keywords - const, volatile, etc.</a>
   <br><br>
   <a href="CppCrashDebuggingMemoryLeak.html">Debugging Crash & Memory Leak</a>
   <br><br>
   <a href="../DesignPatterns/introduction.html">Design Patterns in C++ ...</a>
   <br><br>
   <a href="dynamic_cast.html">Dynamic Cast Operator</a>
   <br><br>
   <a href="eclipse_CDT_JNI_MinGW_64bit.html">Eclipse CDT / JNI (Java Native Interface) / MinGW</a>
   <br><br>
   <a href="embeddedSystemsProgramming.html">Embedded Systems Programming I - Introduction</a>
   <br><br>
   <a href="embeddedSystemsProgramming_gnu_toolchain_ARM_cross_compiler.html">Embedded Systems Programming II - gcc ARM Toolchain and Simple Code on Ubuntu and Fedora</a>
   <br><br>
   <a href="embeddedSystemsProgramming_GNU_ARM_ToolChain_Eclipse_CDT_plugin.html">Embedded Systems Programming III - Eclipse CDT Plugin for gcc ARM Toolchain </a>
   <br><br>
   <a href="exceptions.html">Exceptions</a> 
   <br><br>
   <a href="friendclass.html">Friend Functions and Friend Classes</a>
   <br><br>
   <a href="fstream_input_output.html">fstream: input & output</a>
   <br><br>
   <a href="function_overloading.html">Function Overloading</a>
   <br><br>
   <a href="functor_function_object_stl_intro.html">Functors (Function Objects) I - Introduction</a>
   <br><br>
   <a href="functor_function_object_stl_2.html">Functors (Function Objects) II - Converting function to functor</a>
   <br><br>
   <a href="functors.html">Functors (Function Objects) - General</a>
   <br><br>
   <br><br>
   <a href="Git/Git_GitHub_Express.html">Git and GitHub Express...</a>
   <br><br>
   <a href="google_unit_test_gtest.html">GTest (Google Unit Test) with Visual Studio 2012</a>
   <br><br>
   <a href="multipleinheritance.html">Inheritance & Virtual Inheritance (multiple inheritance) </a>
   <br><br>
   <a href="libraries.html">Libraries - Static, Shared (Dynamic)</a>
   <br><br>
   <a href="linked_list_basics.html">Linked List Basics</a>
   <br><br>
   <a href="linkedlist.html">Linked List Examples</a>
   <br><br>
   <a href="make.html">make & CMake</a>
   <br><br>
   <a href="gnumake.html">make (gnu)</a>
   <br><br>
   <a href="memoryallocation.html">Memory Allocation</a>
   <br><br>
   <a href="multithreaded.html">Multi-Threaded Programming - Terminology - Semaphore, Mutex, Priority Inversion etc.</a>
   <br><br>
   <a href="multithreading_win32A.html">Multi-Threaded Programming II -  Native Thread for Win32 (A) </a>
   <br><br>
   <a href="multithreading_win32B.html">Multi-Threaded Programming II -  Native Thread for Win32 (B) </a>
   <br><br>
   <a href="multithreading_win32C.html">Multi-Threaded Programming II -  Native Thread for Win32 (C) </a>
   <br><br>
   <a href="multithreading_win32.html">Multi-Threaded Programming II - C++ Thread for Win32</a>
   <br><br>
   <a href="multithreading_pthread.html">Multi-Threaded Programming III - C/C++ Class Thread for Pthreads</a>
   <br><br>
   <a href="multithreading_ipc.html">MultiThreading/Parallel Programming - IPC</a>
   <br><br>
   <a href="multithreaded4_cplusplus11.html">Multi-Threaded Programming with C++11 Part A (start, join(), detach(), and ownership)</a>
   <br><br>
   <a href="multithreaded4_cplusplus11B.html">Multi-Threaded Programming with C++11 Part B (Sharing Data - mutex, and race conditions, and deadlock)</a>
   <br><br>
   <a href="multithreadedDebugging.html">Multithread Debugging</a>
   <br><br>
   <a href="object_returning.html">Object Returning</a>
   <br><br>
   <a href="slicing.html">Object Slicing and Virtual Table</a>
   <br><br>
   <a href="opencv.html">OpenCV with C++</a> 
   <br><br>
   <a href="operatoroverloading.html">Operator Overloading I</a> 
   <br><br>
   <a href="operator_oveloading_self_assignment.html">Operator Overloading II - self assignment</a> 
   <br><br>
   <a href="valuevsreference.html">Pass by Value vs. Pass by Reference</a>
   <br><br>
   <a href="pointers.html">Pointers</a>
   <br><br>
   <a href="pointers2_voidpointers_arrays.html">Pointers II - void pointers & arrays</a>
   <br><br>
   <a href="pointers3_function_multidimensional_arrays.html">Pointers III - pointer to function & multi-dimensional arrays</a>
   <br><br>
   <a href="preprocessor_macro.html">Preprocessor - Macro</a>
   <br><br>
   <a href="private_inheritance.html">Private Inheritance</a>
   <br><br>
   <a href="../python/python_cpp_sip.html">Python & C++ with SIP</a>
   <br><br>
   <a href="RandomNumbers.html">(Pseudo)-random numbers in C++</a>
   <br><br>
   <a href="references.html">References for Built-in Types</a>
   <br><br>
   <a href="sockets_server_client.html">Socket - Server & Client</a>
   <br><br>
    <a href="sockets_server_client_QT.html">Socket - Server & Client with Qt (Asynchronous / Multithreading / ThreadPool etc.)</a>
   <br><br>
   <a href="stackunwinding.html">Stack Unwinding</a>
   <br><br>
   <a href="stl_vector_list.html">Standard Template Library (STL) I - Vector & List</a>
   <br><br>
   <a href="stl2_map.html">Standard Template Library (STL) II - Maps</a>
   <br><br>
   <a href="stl2_unorderd_map_cpp11_hash_table_hash_function.html">Standard Template Library (STL) II - unordered_map</a>
   <br><br>
   <a href="stl2B_set.html">Standard Template Library (STL) II - Sets</a>
   <br><br>
   <a href="stl3_iterators.html">Standard Template Library (STL) III - Iterators</a>
   <br><br>
   <a href="stl4_algorithms.html">Standard Template Library (STL) IV - Algorithms</a>
   <br><br>
   <a href="stl5_function_objects.html">Standard Template Library (STL) V - Function Objects</a>
   <br><br>
   <a href="statics.html">Static Variables and Static Class Members</a>
   <br><br>
   <a href="string.html">String</a> 
   <br><br>
   <a href="string2.html">String II - sstream etc.</a> 
   <br><br>
   <a href="assembly.html">Taste of Assembly</a>
   <br><br>
   <a href="templates.html">Templates</a>
   <br><br>
   <a href="template_specialization_function_class.html">Template Specialization</a>
   <br><br>
   <a href="template_specialization_traits.html">Template Specialization - Traits</a>
   <br><br>
   <a href="template_declaration_definition_header_implementation_file.html">Template Implementation & Compiler (.h or .cpp?)</a>
   <br><br>
   <a href="this_pointer.html">The this Pointer</a>
   <br><br>
   <a href="typecast.html">Type Cast Operators</a>
   <br><br>
   <a href="upcasting_downcasting.html">Upcasting and Downcasting</a>
   <br><br>
   <a href="virtual_destructors_shared_ptr.html">Virtual Destructor & boost::shared_ptr</a>
   <br><br>
   <a href="virtualfunctions.html">Virtual Functions</a>
   <br><br>
   <br><br>
   <i>Programming Questions and Solutions &darr;</i>
      <br><br>
       <a href="quiz_strings_arrays.html">Strings and Arrays</a>
       <br><br>
       <a href="quiz_linkedlist.html">Linked List</a>
       <br><br>
       <a href="quiz_recursion.html">Recursion</a>
       <br><br>
       <a href="quiz_bit_manipulation.html">Bit Manipulation</a> 
       <br><br>
       <a href="smallprograms.html">Small Programs (string, memory functions etc.)</a>
       <br><br>
       <a href="quiz_math_probability.html">Math & Probability</a>
       <br><br>
       <a href="quiz_multithreading.html">Multithreading</a>
       <br><br>
       <a href="google_interview_questions.html">140 Questions by Google</a> 
       <br><br>
       <br><br>
   <a href="../Qt/Qt5_Creating_QtQuick2_QML_Application_Animation_A.html">Qt 5 EXPRESS...</a>
   <br><br>
   <a href="../Win32API/Win32API_DLL.html">Win32 DLL ...</a>
   <br><br>
   <a href="cppNews.html">Articles On C++</a> 
   <br><br>
   <a href="C11/C11_initializer_list.html">What's new in C++11...</a> 
   <br><br>
   <a href="C11/1_C11_creating_thread.html">C++11 Threads EXPRESS...</a> 
   <br><br>
   <a href="../OpenCV/opencv_3_tutorial_imgproc_gausian_median_blur_bilateral_filter_image_smoothing.html">OpenCV...</a> 


<br />



  		
  	    </div>
          </div>
        </div>
      </div> <!-- / section -->
    </div>
  </div>

  <br>
<br>
<br>
<br>

<div class="custom-disqus">
<!-- Disqus -->
<!-- Disqus disabled Oct 17, 2016 
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
     
    var disqus_config = function () {
        this.page.url = window.location.href;
        this.page.identifier = document.title;
    };
    
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        
        s.src = '//bogotobogocom.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
     
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
---- Disable -->
<!-- Disqus ends here -->
</div>

<br>
<br>
<br>
<br>


<!-- footer starts here -->
<footer id="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-4 widget">
        <h3 class="widget-title">Contact</h3>
        <div class="widget-body">
          <p>BogoToBogo<br>
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
          </p>  
        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title">Follow Bogotobogo</h3>
        <div class="widget-body">

          <!--
          <ul>
            <li><a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a></li>
            <li><a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a></li>
            <li><a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a></li>
          </ul>
          -->
             <h3>
             <a href="https://www.facebook.com/KHongSanFrancisco" target="_unknown"><i class="fa fa-facebook"></i></a> 
             <a href="https://twitter.com/KHongTwit" target="_unknown"><i class="fa fa-twitter"></i></a> 
             <a href="https://plus.google.com/u/0/+KHongSanFrancisco/posts" target="_unknown"><i class="fa fa-google-plus"></i> </a> 
             </h3>

        </div>
      </div>

      <div class="col-md-4 widget">
        <h3 class="widget-title"><a href="../about_us.html">About Us</a></h3>
        <div class="widget-body">
            <a href="mailto:#">contactus@bogotobogo.com</a><br>
            <br>
            Golden Gate Ave, San Francisco, CA 94115
          </p>  
        </div>
      </div>

    </div> 
  </div>
</footer>

<footer id="underfooter">
  <div class="container">
    <div class="row">
      
      <div class="col-md-6 widget">
        <div class="widget-body">
          <p>Golden Gate Ave, San Francisco, CA 94115 </p>
        </div>
      </div>

      <div class="col-md-6 widget">
        <div class="widget-body">
          <p class="text-right">
            Copyright &copy; 2016, bogotobogo<br> 
            Design: <a href="../index.html" rel="designer">Web Master</a> </p>
        </div>
      </div>

    </div>
  </div>
</footer>

  <!-- JavaScript libs are placed at the end of the document so the pages load faster -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<script type="text/javascript"
     src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- D3.js -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<!-- Google Analytics -->
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-12016988-2']);
    _gaq.push(['_trackPageview']);
    
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

<!-- Google Analytics --> 
<!-- We need this for Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43017326-1', 'bogotobogo.com');
  ga('send', 'pageview');

</script>
  
<!-- Google+ -->
<script type="text/javascript" src="http://apis.google.com/js/plusone.js"></script>

</body>

<!-- Mirrored from www.bogotobogo.com/cplusplus/memoryallocation.php by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 11 Dec 2017 15:00:07 GMT -->
</html>

